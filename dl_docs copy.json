[
  {
    "command": "dl_abs",
    "category": "Arithmetic",
    "synopsis": "dl_abs dynlist_name | dl_abs number",
    "brief": "Computes the element-wise absolute value of a dynamic list. Returns a new list.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as input (or float if input is mixed or float)"
    },
    "errors": [
      "TCL_ERROR if input list is not found, is a string list, or if a general math error occurs."
    ],
    "example": "set myList [dl_create -2 0 3.5 -1.2]\nset absList [dl_abs $myList] ;# absList will be [2 0 3.5 1.2]\ndl_abs -5.5 ;# returns a new list containing [5.5]",
    "see_also": ["dl_negate", "dl_sign"]
  },
  {
    "command": "dl_acos",
    "category": "Arithmetic / Trigonometric",
    "synopsis": "dl_acos dynlist_name | dl_acos number",
    "brief": "Computes the element-wise arc cosine of a dynamic list. Input values must be between -1 and 1. Returns a new list of floats (radians).",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"],
      "constraints": "Elements must be in the range [-1.0, 1.0]."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float",
      "brief": "Values are in radians."
    },
    "errors": [
      "TCL_ERROR if input list is not found, is a string list, or if any element is outside the range [-1.0, 1.0]."
    ],
    "example": "set values [dl_create 0 0.5 1 -0.8]\nset acos_values [dl_acos $values]\ndl_acos 0.707",
    "see_also": ["dl_cos", "dl_asin", "dl_atan"]
  },
  {
    "command": "dl_add",
    "category": "Arithmetic",
    "synopsis": "dl_add list1 list2 [list3 ...]",
    "brief": "Performs element-wise addition of two or more dynamic lists. Returns a new list.",
    "inputs": {
      "type": "DynList",
      "length": "2+",
      "element_types": ["numeric"],
      "constraints": "Lists must be numeric and broadcastable (e.g., same length or one is a scalar/1-element list)."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Numeric (promoted to float if mixed types)"
    },
    "errors": [
      "TCL_ERROR if any input list is not found, not numeric, or if lists are not compatible for addition."
    ],
    "example": "set l1 [dl_create 1 2 3]\nset l2 [dl_create 10 20 30]\nset l3 [dl_add $l1 $l2]      ;# l3 is [11 22 33]\nset l4 [dl_add $l1 5]        ;# l4 is [6 7 8]\nset l5 [dl_add $l1 $l2 $l4]  ;# l5 is [17 29 41]",
    "see_also": ["dl_sub", "dl_mult", "dl_div", "dl_increment"]
  },
  {
    "command": "dl_and",
    "category": "Logical",
    "synopsis": "dl_and list1 list2 [list3 ...]",
    "brief": "Performs element-wise logical AND operation on two or more numeric dynamic lists. Returns a new list of 0s and 1s.",
    "inputs": {
      "type": "DynList",
      "length": "2+",
      "element_types": ["numeric"],
      "constraints": "Lists must be numeric (not string) and broadcastable."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "Result contains 0 (false) or 1 (true)."
    },
    "errors": [
      "TCL_ERROR if any input list is not found, is a string list, or if lists are not compatible for the AND operation."
    ],
    "example": "set l1 [dl_create 1 0 1 0]\nset l2 [dl_create 1 1 0 0]\nset l3 [dl_and $l1 $l2]   ;# l3 is [1 0 0 0]\nset l4 [dl_and $l1 1]     ;# l4 is [1 0 1 0] (1 is broadcast)\nset l5 [dl_create 1 1 1 1]\nset l6 [dl_and $l1 $l2 $l5] ;# l6 is [1 0 0 0]",
    "see_also": ["dl_or", "dl_not", "dl_eq"]
  },
  {
    "command": "dl_andIndex",
    "category": "Logical / Indexing",
    "synopsis": "dl_andIndex list1 list2 [list3 ...]",
    "brief": "Performs element-wise logical AND on numeric lists and returns a new list containing the indices where the result is true.",
    "inputs": {
      "type": "DynList",
      "length": "2+",
      "element_types": ["numeric"],
      "constraints": "Lists must be numeric (not string) and broadcastable."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 0-based indices where the logical AND is true."
    },
    "errors": [
      "TCL_ERROR if any input list is not found, is a string list, or if lists are not compatible for the AND operation."
    ],
    "example": "set l1 [dl_create 1 0 1 0 1]\nset l2 [dl_create 1 1 0 0 1]\nset idx [dl_andIndex $l1 $l2]   ;# idx is [0 4] (indices where l1[i] AND l2[i] is true)\nset l3 [dl_create 0 1 1 1 1]\nset idx2 [dl_andIndex $l1 $l2 $l3] ;# idx2 is [4]",
    "see_also": ["dl_and", "dl_orIndex", "dl_eqIndex", "dl_select"]
  },
  {
    "command": "dl_append",
    "category": "Manipulation",
    "synopsis": "dl_append dynlist val [val2 ...]",
    "brief": "Appends one or more values to the end of a dynamic list. Modifies the list in place.",
    "inputs": {
      "type": "varied",
      "length": "2+",
      "element_types": ["string (dynlist_name)", "any (value_to_append)", "..."]
    },
    "returns": {
      "type": "string",
      "new_object": false,
      "brief": "The name of the modified dynamic list."
    },
    "side_effects": [
      "The specified 'dynlist' is modified by appending the new value(s)."
    ],
    "errors": [
      "TCL_ERROR if dynlist is not found, or if a value cannot be converted to the dynlist's datatype (e.g., appending a string to an integer list, or appending a non-dynlist name to a list of lists)."
    ],
    "example": "set myList [dl_create 1 2 3]\ndl_append $myList 4 5 ;# myList is now [1 2 3 4 5]\n\nset listOfLists [dl_llist]\nset item1 [dl_create 10]\nset item2 [dl_create 20]\ndl_append $listOfLists $item1 $item2 ;# listOfLists now contains two sub-lists",
    "see_also": ["dl_prepend", "dl_insert", "dl_concat", "dl_create"]
  },
  {
    "command": "dl_asin",
    "category": "Arithmetic / Trigonometric",
    "synopsis": "dl_asin dynlist_name | dl_asin number",
    "brief": "Computes the element-wise arc sine of a dynamic list or number. Input values must be between -1 and 1. Returns a new list of floats (radians).",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"],
      "constraints": "Elements must be in the range [-1.0, 1.0]."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float",
      "brief": "Values are in radians."
    },
    "errors": [
      "TCL_ERROR if input list is not found, is a string list, or if any element is outside the range [-1.0, 1.0]."
    ],
    "example": "set values [dl_create 0 0.5 1 -0.707]\nset asin_values [dl_asin $values]\ndl_asin 0.866",
    "see_also": ["dl_sin", "dl_acos", "dl_atan"]
  },
  {
    "command": "dl_atan",
    "category": "Arithmetic / Trigonometric",
    "synopsis": "dl_atan dynlist_name | dl_atan number",
    "brief": "Computes the element-wise arc tangent of a dynamic list or number. Returns a new list of floats (radians).",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float",
      "brief": "Values are in radians (typically in the range -PI/2 to PI/2)."
    },
    "errors": [
      "TCL_ERROR if input list is not found or is a string list."
    ],
    "example": "set values [dl_create 0 1 -1 0.5]\nset atan_values [dl_atan $values]\ndl_atan Infinity",
    "see_also": ["dl_tan", "dl_acos", "dl_asin", "dl_atan2"]
  },
  {
    "command": "dl_atan2",
    "category": "Arithmetic / Trigonometric",
    "synopsis": "dl_atan2 y_list x_list | dl_atan2 y_val x_val | dl_atan2 y_list x_val | dl_atan2 y_val x_list",
    "brief": "Computes the element-wise arc tangent of y/x, using the signs of both arguments to determine the quadrant of the result. Returns a new list of floats (radians).",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 2,
      "element_types": ["numeric", "numeric"],
      "constraints": "Inputs must be numeric and broadcastable."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float",
      "brief": "Values are in radians (in the range -PI to PI)."
    },
    "errors": [
      "TCL_ERROR if input lists/values are not found, not numeric, or not compatible."
    ],
    "example": "set y_coords [dl_create 1 -1  1 -1]\nset x_coords [dl_create 1  1 -1 -1]\nset angles_rad [dl_atan2 $y_coords $x_coords] ;# e.g., atan2(1,1) is PI/4\ndl_atan2 0 -1 ;# results in PI",
    "see_also": ["dl_atan", "dl_sin", "dl_cos"]
  },
  {
    "command": "dl_bcycle",
    "category": "Manipulation / List of Lists",
    "synopsis": "dl_bcycle dynlist_name [shift]",
    "brief": "Cycles the elements of the bottom-most sublists of a list of lists (or the elements of a simple list) by a specified 'shift' amount. Positive shift cycles right, negative cycles left. Default shift is 1. Returns a new list.",
    "inputs": {
      "type": "varied",
      "length": "1-2",
      "element_types": ["string (dynlist_name)", "integer (shift_amount)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as input list (preserves structure and element types of sublists)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name not found, or if shift (if provided) is not an integer."
    ],
    "example": "set lol [dl_llist [dl_create 1 2 3] [dl_create a b c d]]\nset cycled1 [dl_bcycle $lol]      ;# shift=1: lol becomes [[3 1 2] [d a b c]]\nset cycled2 [dl_bcycle $lol 2]    ;# shift=2: lol becomes [[2 3 1] [c d a b]]\nset cycled3 [dl_bcycle $lol -1]   ;# shift=-1: lol becomes [[2 3 1] [b c d a]]\n\nset sl [dl_create 10 20 30 40]\nset cycled_sl1 [dl_bcycle $sl]    ;# shift=1: sl becomes [40 10 20 30]\nset cycled_sl2 [dl_bcycle $sl -1] ;# shift=-1: sl becomes [20 30 40 10]",
    "see_also": ["dl_bshift", "dl_cycle", "dl_shift", "dl_subshift"]
  },
  {
    "command": "dl_bins",
    "category": "Utility / Histogramming",
    "synopsis": "dl_bins start stop nbins",
    "brief": "Generates a dynamic list of bin boundaries suitable for creating a histogram. Given a range (start, stop) and a number of bins (nbins), it returns a list of nbins+1 values representing the edges of these bins.",
    "inputs": {
      "type": "varied",
      "length": 3,
      "element_types": ["numeric (start_value)", "numeric (stop_value)", "integer (number_of_bins)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float (or same as start/stop if they are integers and result in integer bins)",
      "brief": "A list of nbins+1 bin edge values."
    },
    "errors": [
      "TCL_ERROR if start/stop are not numeric, nbins is not an integer, or if nbins is non-positive."
    ],
    "example": "set myBinEdges [dl_bins 0 10 5]  ;# myBinEdges might be [0.0 2.0 4.0 6.0 8.0 10.0]\nset anotherSet [dl_bins -1.5 1.5 6] ;# could be [-1.5 -1.0 -0.5 0.0 0.5 1.0 1.5]",
    "see_also": ["dl_hist", "dl_histLists", "dl_cut"]
  },
  {
    "command": "dl_bmax",
    "category": "Reduction / List of Lists",
    "synopsis": "dl_bmax dynlist_name",
    "brief": "Computes the maximum value of each bottom-most sublist in a (potentially nested) dynamic list. Returns a new list with the same structure as the input, but with each bottom-most list replaced by its maximum value.",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["numeric (potentially nested)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as elements of bottom-most input sublists (preserves structure above bottom-most lists)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found, or if any bottom-most list is empty or non-numeric."
    ],
    "example": "set lol [dl_llist [dl_create 1 5 2] [dl_create 10 0 3]]\nset bmax_lol [dl_bmax $lol]   ;# bmax_lol will be a list of lists: [[5] [10]]\n\nset simple_list [dl_create -1 7 3]\nset bmax_simple [dl_bmax $simple_list] ;# bmax_simple will be [7]\n\nset nested [dl_llist [dl_llist [dl_create 1 2] [dl_create 3 8]] [dl_create 4 5]]\nset bmax_nested [dl_bmax $nested] ;# bmax_nested is [[2 8] [5]]",
    "see_also": ["dl_max", "dl_bmin", "dl_bmins", "dl_bmean", "dl_bsums"]
  },
  {
    "command": "dl_bmean",
    "category": "Reduction / List of Lists",
    "synopsis": "dl_bmean dynlist_name",
    "brief": "Computes the mean value of each bottom-most sublist in a (potentially nested) dynamic list. Returns a new list with the same structure as the input, but with each bottom-most list replaced by its mean value (float).",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["numeric (potentially nested)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float (preserves structure above bottom-most lists)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found, or if any bottom-most list is empty or non-numeric."
    ],
    "example": "set lol [dl_llist [dl_create 1 2 3] [dl_create 10 30]]\nset bmean_lol [dl_bmean $lol]   ;# bmean_lol will be a list of lists: [[2.0] [20.0]]\n\nset simple_list [dl_create 1 2 6]\nset bmean_simple [dl_bmean $simple_list] ;# bmean_simple will be [3.0]\n\nset nested [dl_llist [dl_llist [dl_create 1 3] [dl_create 0 10]] [dl_create 4 5 6]]\nset bmean_nested [dl_bmean $nested] ;# bmean_nested is [[2.0 5.0] [5.0]]",
    "see_also": ["dl_mean", "dl_bmax", "dl_bmin", "dl_bsums", "dl_bstds"]
  },
  {
    "command": "dl_bmin",
    "category": "Reduction / List of Lists",
    "synopsis": "dl_bmin dynlist_name",
    "brief": "Computes the minimum value of each bottom-most sublist in a (potentially nested) dynamic list. Returns a new list with the same structure as the input, but with each bottom-most list replaced by its minimum value.",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["numeric (potentially nested)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as elements of bottom-most input sublists (preserves structure above bottom-most lists)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found, or if any bottom-most list is empty or non-numeric."
    ],
    "example": "set lol [dl_llist [dl_create 1 5 2] [dl_create 10 0 3]]\nset bmin_lol [dl_bmin $lol]   ;# bmin_lol will be a list of lists: [[1] [0]]\n\nset simple_list [dl_create -1 7 3]\nset bmin_simple [dl_bmin $simple_list] ;# bmin_simple will be [-1]\n\nset nested [dl_llist [dl_llist [dl_create 1 2] [dl_create 3 0]] [dl_create -4 5]]\nset bmin_nested [dl_bmin $nested] ;# bmin_nested is [[1 0] [-4]]",
    "see_also": ["dl_min", "dl_bmax", "dl_bmean", "dl_bsums"]
  },
  {
    "command": "dl_bmins",
    "category": "Reduction / List of Lists",
    "synopsis": "dl_bmins dynlist_name",
    "brief": "Alias for `dl_bmin`. Computes the minimum value of each bottom-most sublist.",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["numeric (potentially nested)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as elements of bottom-most input sublists (preserves structure above bottom-most lists)"
    },
    "errors": [
      "See dl_bmin."
    ],
    "example": "# See dl_bmin for examples\nset my_list [dl_llist [dl_create 10 2] [dl_create 5 8]]\nset mins_list [dl_bmins $my_list] ;# mins_list is [[2] [5]]",
    "see_also": ["dl_bmin", "dl_min", "dl_bmaxs", "dl_bmeans", "dl_bsums"]
  },
  {
    "command": "dl_breverse",
    "category": "Manipulation / List of Lists",
    "synopsis": "dl_breverse dynlist_name",
    "brief": "Reverses the elements of each bottom-most sublist in a (potentially nested) dynamic list. If the input is a simple list, it reverses that list. Returns a new list.",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["any (potentially nested)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as input list (preserves structure and element types of sublists)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found."
    ],
    "example": "set lol [dl_llist [dl_create 1 2 3] [dl_slist a b c] [dl_create 10 20]]\nset breversed_lol [dl_breverse $lol]\n# breversed_lol will be {{3 2 1} {c b a} {20 10}}\n\nset simple_list [dl_create 1 2 3 4]\nset breversed_simple [dl_breverse $simple_list]\n# breversed_simple will be {4 3 2 1}",
    "see_also": ["dl_reverse", "dl_reverseAll", "dl_permute"]
  },
  {
    "command": "dl_bshift",
    "category": "Manipulation / List of Lists",
    "synopsis": "dl_bshift dynlist_name [shift]",
    "brief": "Shifts the elements of the bottom-most sublists of a list of lists (or the elements of a simple list) by a specified 'shift' amount. Positive shift moves elements right (filling with 0/empty string), negative shifts left. Default shift is 1. Elements shifted off ends are lost. Returns a new list.",
    "inputs": {
      "type": "varied",
      "length": "1-2",
      "element_types": ["string (dynlist_name)", "integer (shift_amount)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as input list (preserves structure and element types of sublists)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name not found or if shift amount is invalid."
    ],
    "example": "set lol [dl_llist [dl_create 1 2 3] [dl_slist a b c]]\nset bshifted_right [dl_bshift $lol 1]\n# bshifted_right is {{0 1 2} {\"\" a b}}\nset bshifted_left [dl_bshift $lol -1]\n# bshifted_left is {{2 3 0} {b c \"\"}}\n\nset simple [dl_create 1 2 3 4]\nset shifted_simple [dl_bshift $simple 2]\n# shifted_simple is {0 0 1 2}",
    "see_also": ["dl_bcycle", "dl_shift", "dl_cycle", "dl_subshift"]
  },
  {
    "command": "dl_bsort",
    "category": "Manipulation / List of Lists / Sorting",
    "synopsis": "dl_bsort dynlist_name",
    "brief": "Sorts the elements of each bottom-most sublist in a (potentially nested) dynamic list in ascending order. If the input is a simple list, it sorts that list. Returns a new list.",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["any (potentially nested, sortable elements within bottom-most lists)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as input list (preserves structure and element types of sublists)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found or if elements within a sublist are not mutually sortable (e.g., mixing strings and numbers in a way that Tcl can't compare)."
    ],
    "example": "set lol [dl_llist [dl_create 3 1 2] [dl_slist c a b] [dl_create 20 5 10]]\nset bsorted_lol [dl_bsort $lol]\n# bsorted_lol will be {{1 2 3} {a b c} {5 10 20}}\n\nset simple_list [dl_create 3 1 4 2]\nset bsorted_simple [dl_bsort $simple_list]\n# bsorted_simple will be {1 2 3 4}",
    "see_also": ["dl_sort", "dl_bsortIndices", "dl_sortIndices", "dl_sortByList"]
  },
  {
    "command": "dl_bsortIndices",
    "category": "Manipulation / List of Lists / Sorting / Indexing",
    "synopsis": "dl_bsortIndices dynlist_name",
    "brief": "Sorts each bottom-most sublist in a (potentially nested) dynamic list and returns a new list containing the 0-based indices that would sort each original sublist. If the input is a simple list, it returns the sort indices for that list.",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["any (potentially nested, sortable elements within bottom-most lists)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer (preserves structure above bottom-most lists, bottom-most lists contain indices)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found or if elements within a sublist are not mutually sortable."
    ],
    "example": "set lol [dl_llist [dl_create 30 10 20] [dl_slist c a b]]\nset bsorted_indices_lol [dl_bsortIndices $lol]\n# bsorted_indices_lol will be {{1 2 0} {1 2 0}} (indices to sort each sublist)\n\nset simple_list [dl_create 30 10 40 20]\nset bsorted_indices_simple [dl_bsortIndices $simple_list]\n# bsorted_indices_simple will be {1 3 0 2}",
    "see_also": ["dl_bsort", "dl_sortIndices", "dl_sort", "dl_permute"]
  },
  {
    "command": "dl_bstds",
    "category": "Reduction / List of Lists / Statistics",
    "synopsis": "dl_bstds dynlist_name",
    "brief": "Computes the standard deviation of each bottom-most sublist in a (potentially nested) dynamic list. Returns a new list with the same structure as the input, but with each bottom-most list replaced by its standard deviation value (float).",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["numeric (potentially nested)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float (preserves structure above bottom-most lists)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found, or if any bottom-most list is empty, non-numeric, or has insufficient elements for std dev calculation (e.g., fewer than 2 elements for sample std dev)."
    ],
    "example": "set lol [dl_llist [dl_create 1 2 3] [dl_create 10 20 30 40]]\nset bstds_lol [dl_bstds $lol]   ;# bstds_lol might be e.g. [[1.0] [12.91]] (actual values depend on sample vs population std dev)\n\nset simple_list [dl_create 1 1 1 1]\nset bstds_simple [dl_bstds $simple_list] ;# bstds_simple will be [0.0]\n\nset nested [dl_llist [dl_llist [dl_create 1 3] [dl_create 0 10 5]] [dl_create 4 5 6]]\nset bstds_nested [dl_bstds $nested] ;# e.g. [[1.414] [5.0] [1.0]]",
    "see_also": ["dl_std", "dl_bmean", "dl_bvar", "dl_hstd", "dl_hvar"]
  },
  {
    "command": "dl_bsums",
    "category": "Reduction / List of Lists",
    "synopsis": "dl_bsums dynlist_name",
    "brief": "Computes the sum of each bottom-most sublist in a (potentially nested) dynamic list. Returns a new list with the same structure as the input, but with each bottom-most list replaced by its sum.",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["numeric (potentially nested)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Numeric (same as elements of bottom-most input sublists if uniform, else promoted, e.g., to float. Preserves structure above bottom-most lists)."
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found, or if any bottom-most list is empty or contains non-numeric elements that cannot be summed."
    ],
    "example": "set lol [dl_llist [dl_create 1 2 3] [dl_create 10 20.5]]\nset bsums_lol [dl_bsums $lol]   ;# bsums_lol will be a list of lists: [[6] [30.5]]\n\nset simple_list [dl_create -1 7 3 0.5]\nset bsums_simple [dl_bsums $simple_list] ;# bsums_simple will be [9.5]\n\nset nested [dl_llist [dl_llist [dl_create 1 2] [dl_create 3 4]] [dl_create 5 6]]\nset bsums_nested [dl_bsums $nested] ;# bsums_nested is [[3 7] [11]]",
    "see_also": ["dl_sum", "dl_bmean", "dl_bmin", "dl_bmax", "dl_prod"]
  },
  {
    "command": "dl_ceil",
    "category": "Arithmetic",
    "synopsis": "dl_ceil dynlist_name | dl_ceil number",
    "brief": "Computes the element-wise ceiling of a dynamic list or number (smallest integer not less than each value). Returns a new list.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer (or float representing an integer, e.g. 2.0)"
    },
    "errors": [
      "TCL_ERROR if input is not a valid dynlist or number, or if the list is a string list, or for general math errors."
    ],
    "example": "set myList [dl_create 1.2 2.0 -3.7 4]]\nset ceilList [dl_ceil $myList] ;# ceilList will be [2.0 2.0 -3.0 4.0] (or integer equivalents)\ndl_ceil -5.5 ;# returns a new list containing [-5.0]",
    "see_also": ["dl_floor", "dl_round", "dl_int"]
  },
  {
    "command": "dl_char",
    "category": "Conversion",
    "synopsis": "dl_char input_list [output_var_name]",
    "brief": "Converts elements of a numeric dynamic list to their character (byte) equivalents. Returns a new char dynlist.",
    "inputs": {
      "type": "varied",
      "length": "1-2",
      "element_types": ["string (input_list_name)", "string (output_var_name, optional)"]
    },
    "input_list_constraints": {
        "type": "DynList",
        "element_types": ["numeric (integer, float)"],
        "brief": "Input list elements are typically integers or floats; floats are truncated. Values should be in the valid range for char (0-255 or -128-127, depending on signedness interpretation, though typically 0-255). String lists or lists of lists are not suitable."
    },
    "returns": {
      "type": "string (name of new char DynList)",
      "new_object": true,
      "element_type": "char (byte)"
    },
    "side_effects": [
        "If output_var_name is provided, the Tcl variable by that name is set to the name of the new char dynlist."
    ],
    "errors": [
      "TCL_ERROR if input_list is not found, if conversion is not possible (e.g., input is a list of lists), or if output_var_name is invalid (if used)."
    ],
    "example": "set myNums [dl_create 65 66 67.7 97]\nset charList [dl_char $myNums] ;# charList will contain characters 'A', 'B', 'C', 'a' (represented as their byte values)\ndl_char $myNums charVarName ;# charVarName will hold the name of the new char list",
    "see_also": ["dl_int", "dl_float", "dl_short", "dl_uchar", "dl_stringmatch"]
  },
  {
    "command": "dl_choose",
    "category": "Manipulation / Selection",
    "synopsis": "dl_choose source_dynlist_name index_dynlist_name",
    "brief": "Selects elements from 'source_dynlist' based on 0-based indices provided in 'index_dynlist'. Returns a new list containing the chosen elements in the order specified by 'index_dynlist'. Allows for repeated selection of elements.",
    "inputs": {
      "type": "varied",
      "length": 2,
      "element_types": ["string (source_dynlist_name)", "string (index_dynlist_name)"]
    },
    "source_dynlist_constraints": {
        "type": "DynList",
        "element_types": ["any"],
        "brief": "The dynamic list from which elements are chosen."
    },
    "index_dynlist_constraints": {
        "type": "DynList",
        "element_types": ["integer (or numeric coercible to integer)"],
        "brief": "A dynamic list of 0-based indices specifying which elements to choose from 'source_dynlist'. Indices must be within the valid range [0, length(source_dynlist)-1]."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "any (same as elements of source_dynlist)"
    },
    "errors": [
      "TCL_ERROR if 'source_dynlist_name' or 'index_dynlist_name' are not found.",
      "TCL_ERROR if 'index_dynlist' contains non-integer values or out-of-bounds indices.",
      "TCL_ERROR if the wrong number of arguments is provided (expects 2 list names)."
    ],
    "example": "set sourceList [dl_create apple banana cherry date elderberry]\nset indexList [dl_create 0 3 1 3 0]\nset chosenList [dl_choose $sourceList $indexList] ;# chosenList will be a new dynlist containing [apple date banana date apple]",
    "see_also": ["dl_select", "dl_get", "dl_permute", "dl_pickone"]
  },
  {
    "command": "dl_clean",
    "category": "Memory Management",
    "synopsis": "dl_clean",
    "brief": "Deletes all temporary dynamic lists in the current interpreter. Temporary lists are those whose names start with a '%' (e.g., %list0, %list123). Also resets the internal counter for temporary list names.",
    "inputs": {
      "type": "none",
      "length": 0
    },
    "returns": {
      "type": "void (TCL_OK on success)",
      "new_object": false
    },
    "side_effects": [
      "All temporary dynamic lists (names starting with '%') are deleted.",
      "The internal counter for generating temporary list names is reset to 0."
    ],
    "errors": [
      "TCL_ERROR if internal interpreter data (DLSHINFO) cannot be accessed (very unlikely)."
    ],
    "example": "dl_create 1 2 3 ;# Might create a temporary list like %list0\nset x [dl_add [dl_create 10] [dl_create 20]] ;# x will be name of a new temp list like %list1\ndl_clean ;# Deletes %list0, %list1 (if they were indeed temp names) and any other such lists.",
    "see_also": ["dl_delete", "dl_cleanReturns", "dg_clean"]
  },
  {
    "command": "dl_cleanReturns",
    "category": "Memory Management",
    "synopsis": "dl_cleanReturns",
    "brief": "Deletes all 'return' dynamic lists in the current interpreter. Return lists are typically those created by 'dl_return' and have names starting with a '>' (e.g., >0<). Also resets the internal counter for return list names.",
    "inputs": {
      "type": "none",
      "length": 0
    },
    "returns": {
      "type": "void (TCL_OK on success)",
      "new_object": false
    },
    "side_effects": [
      "All 'return' dynamic lists (names starting with '>') are deleted.",
      "The internal counter for generating return list names is reset to 0."
    ],
    "errors": [
      "TCL_ERROR if internal interpreter data (DLSHINFO) cannot be accessed (very unlikely)."
    ],
    "example": "proc my_proc {val} {\n  set temp_list [dl_create $val $val*2]\n  return [dl_return $temp_list]\n}\nset ret_list_name [my_proc 5] ;# ret_list_name might be '>0<'\ndl_cleanReturns ;# Deletes the list named by ret_list_name (e.g., >0<) and any other such lists.",
    "see_also": ["dl_delete", "dl_clean", "dl_return"]
  },
  {
    "command": "dl_clist",
    "category": "Creation",
    "synopsis": "dl_clist [value1 value2 ... | {value_list} | dynlist_name1 dynlist_name2 ...]",
    "brief": "Creates a new dynamic list of type character (byte). Initializes with optional values, which can be individual numeric character codes, a Tcl list of codes, or elements from other dynlists (converted to char).",
    "inputs": {
      "type": "varied (values, Tcl list, or dynlist names)",
      "length": "0+",
      "element_types": ["integer (character code)", "Tcl list of integer character codes", "string (dynlist_name)"],
      "constraints": "Numeric values are treated as character codes (e.g., 65 for 'A'). Elements from other dynlists are converted to char if possible (numeric types truncated, strings likely take first char or error, lists of lists likely error)."
    },
    "returns": {
      "type": "string (name of new char DynList)",
      "new_object": true,
      "element_type": "char (byte)"
    },
    "errors": [
      "TCL_ERROR if non-numeric values are provided that cannot be converted to char codes.",
      "TCL_ERROR if a named dynlist argument is not found.",
      "TCL_ERROR if conversion from elements of a source dynlist to char is not possible."
    ],
    "example": "set charList1 [dl_clist 65 66 67]       ;# charList1 contains 'A', 'B', 'C' (byte values)\nset charList2 [dl_clist {72 101 108 108 111}] ;# charList2 contains 'H', 'e', 'l', 'l', 'o'\nset numList [dl_create 97 98.5]\nset charList3 [dl_clist $numList 33]    ;# charList3 contains 'a', 'b', '!' (98.5 truncated to 98)",
    "see_also": ["dl_create", "dl_ilist", "dl_flist", "dl_slist", "dl_llist", "dl_char"]
  },
  {
    "command": "dl_collapse",
    "category": "Manipulation / Restructuring",
    "synopsis": "dl_collapse list_of_lists_name",
    "brief": "Collapses a list of lists by one level, concatenating all sublists into a new single list. The data type of the new list is determined by the elements in the sublists.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["The name of a dynamic list which must be a list of lists (type DF_LIST). Each sublist contains the elements to be concatenated."]
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "any (determined by common type of elements in sublists; may be promoted, e.g., int + float -> float)"
    },
    "errors": [
      "TCL_ERROR if the input is not a valid dynlist name or the list is not found.",
      "TCL_ERROR if the input dynlist is not a list of lists (DF_LIST type).",
      "TCL_ERROR if memory allocation fails."
    ],
    "example": "set lol [dl_llist [dl_create 1 2] [dl_create 3 4 5] [dl_create 6]]\nset flatList [dl_collapse $lol] ;# flatList will be a new dynlist containing [1 2 3 4 5 6]\n\nset mix [dl_llist [dl_ilist 10 20] [dl_flist 30.3 40.4]]\nset flatMix [dl_collapse $mix] ;# flatMix will be a new float dynlist [10.0 20.0 30.3 40.4]",
    "see_also": ["dl_unpack", "dl_deepUnpack", "dl_concat", "dl_pack", "dl_llist"]
  },
  {
    "command": "dl_combine",
    "category": "Creation / Concatenation",
    "synopsis": "dl_combine dynlist1_name dynlist2_name [dynlist3_name ...]",
    "brief": "Creates a new dynamic list by concatenating two or more existing dynamic lists. All input lists must be of the same data type.",
    "inputs": {
      "type": "strings (dynlist_names)",
      "length": "2+",
      "element_types": ["string (name of a dynlist)"],
      "constraints": "All specified dynamic lists must exist and have the same underlying data type (e.g., all DF_LONG, all DF_FLOAT, etc.)."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "Same as the input dynlists."
    },
    "errors": [
      "TCL_ERROR if fewer than two dynlist names are provided.",
      "TCL_ERROR if any dynlist name is not found.",
      "TCL_ERROR if input lists are not of the same data type.",
      "TCL_ERROR if memory allocation for the new list fails."
    ],
    "example": "set listA [dl_create 1 2 3]\nset listB [dl_flist 4.0 5.0]\nset listC [dl_create 6 7]\n# dl_combine $listA $listB ;# This would error as listA (int) and listB (float) are different types\nset combinedList [dl_combine $listA $listC] ;# combinedList will be a new int dynlist [1 2 3 6 7]",
    "see_also": ["dl_concat", "dl_interleave", "dl_append", "dl_create"]
  },
  {
    "command": "dl_concat",
    "category": "Manipulation / Concatenation",
    "synopsis": "dl_concat dest_dynlist_name source_dynlist_name [source_dynlist_name2 ...]",
    "brief": "Concatenates one or more source dynamic lists onto a destination dynamic list. The destination list is modified in-place. All lists must be of the same data type.",
    "inputs": {
      "type": "strings (dynlist_names)",
      "length": "2+",
      "element_types": ["string (name of destination dynlist)", "string (name of source dynlist)"],
      "constraints": "All specified dynamic lists must exist and have the same underlying data type. The first list is the destination and will be modified."
    },
    "returns": {
      "type": "string (name of modified destination DynList)",
      "new_object": false
    },
    "side_effects": [
      "The 'dest_dynlist_name' is modified by appending elements from all 'source_dynlist_name(s)'."
    ],
    "errors": [
      "TCL_ERROR if fewer than two dynlist names are provided.",
      "TCL_ERROR if any dynlist name is not found.",
      "TCL_ERROR if source lists are not of the same data type as the destination list.",
      "TCL_ERROR if memory (re)allocation for the destination list fails during concatenation."
    ],
    "example": "set list1 [dl_create 1 2]\nset list2 [dl_create 3 4]\nset list3 [dl_create 5 6]\ndl_concat $list1 $list2 $list3 ;# list1 is now [1 2 3 4 5 6]\n# dl_concat $list1 [dl_flist 7.0 8.0] ;# This would error if list1 is an int list.",
    "see_also": ["dl_combine", "dl_append", "dl_interleave"]
  },
  {
    "command": "dl_conv",
    "category": "Arithmetic / Signal Processing",
    "synopsis": "dl_conv data_dynlist_name kernel_dynlist_name [mode]",
    "brief": "Performs 1D convolution of a data dynamic list with a kernel dynamic list. Returns a new list containing the result.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["string (data_dynlist_name)", "string (kernel_dynlist_name)", "string (mode, optional)"],
      "constraints": "'data_dynlist_name' and 'kernel_dynlist_name' must refer to 1D numeric dynamic lists. 'mode', if provided, is a string, typically one of 'full', 'same', or 'valid'. Defaults to 'full' if omitted. Kernel list must not be empty."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "float"
    },
    "errors": [
      "TCL_ERROR if input lists are not found, are not numeric, or are not 1D.",
      "TCL_ERROR if the kernel list is empty.",
      "TCL_ERROR if an invalid 'mode' string is provided.",
      "TCL_ERROR for memory allocation failures."
    ],
    "example": "set data [dl_ilist 1 2 3 4 5]\nset kernel [dl_ilist 1 0 -1]\nset res_full [dl_conv $data $kernel]          ;# Result: [1.0 2.0 2.0 2.0 2.0 -4.0 -5.0] (length 7)\nset res_same [dl_conv $data $kernel same]    ;# Result: [2.0 2.0 2.0 2.0 -4.0] (length 5)\nset res_valid [dl_conv $data $kernel valid]   ;# Result: [2.0 2.0 2.0] (length 3)",
    "see_also": ["dl_conv2", "dl_add", "dl_mult", "dl_diff"]
  },
  {
    "command": "dl_conv2",
    "category": "Arithmetic / Signal Processing / Filtering",
    "synopsis": "dl_conv2 data_dynlist_name b_coeffs_dynlist_name a_coeffs_dynlist_name",
    "brief": "Performs a 1D recursive (IIR-like) convolution/filter operation on a data dynamic list using feedforward (b) and feedback (a) coefficients. Returns a new list.",
    "inputs": {
      "type": "strings (dynlist_names)",
      "length": 3,
      "element_types": ["string (data_dynlist_name)", "string (b_coeffs_dynlist_name)", "string (a_coeffs_dynlist_name)"],
      "constraints": "All lists must be 1D numeric dynamic lists. The first element of 'a_coeffs_dynlist_name' (a[0]) should ideally be 1 or non-zero for stability; if not 1, it might be used for normalization. Coefficient lists cannot be empty."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "float"
    },
    "errors": [
      "TCL_ERROR if input lists are not found, are not numeric, or are not 1D.",
      "TCL_ERROR if coefficient lists (b or a) are empty.",
      "TCL_ERROR if a[0] coefficient is zero and not handled by internal normalization, potentially leading to division by zero.",
      "TCL_ERROR for memory allocation failures or other numerical issues during filtering."
    ],
    "example": "set signal [dl_ilist 1 0 0 0 0]\nset b_coeffs [dl_flist 1.0]       ;# FIR filter: y[n] = x[n] + 0.5*x[n-1]\nset a_coeffs [dl_flist 1.0 -0.5]  ;# IIR filter: y[n] = x[n] + 0.5*y[n-1]\n# Example for a simple IIR filter (e.g. y[n] = x[n] + 0.8*y[n-1]):\nset b_iir [dl_flist 1.0]\nset a_iir [dl_flist 1.0 -0.8]\nset filtered_signal [dl_conv2 $signal $b_iir $a_iir]\n# filtered_signal could be [1.0 0.8 0.64 0.512 0.4096]",
    "see_also": ["dl_conv", "dl_diff"]
  },
  {
    "command": "dl_cos",
    "category": "Arithmetic / Trigonometric",
    "synopsis": "dl_cos dynlist_name | dl_cos number_radians",
    "brief": "Computes the element-wise cosine of a dynamic list or a single number. Input values are assumed to be in radians. Returns a new list of floats.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"],
      "constraints": "Input elements are interpreted as angles in radians."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float",
      "brief": "Resulting values are in the range [-1.0, 1.0]."
    },
    "errors": [
      "TCL_ERROR if input list is not found or is a string list.",
      "TCL_ERROR for general math errors during cosine calculation."
    ],
    "example": "set angles_rad [dl_create 0 1.5708 3.14159 6.28318] ;# 0, PI/2, PI, 2*PI\nset cos_values [dl_cos $angles_rad] ;# cos_values will be approximately [1.0 0.0 -1.0 1.0]\ndl_cos 0.7854 ;# cos(PI/4) approx 0.707",
    "see_also": ["dl_sin", "dl_tan", "dl_acos", "dl_cosh"]
  },
  {
    "command": "dl_cosh",
    "category": "Arithmetic / Hyperbolic",
    "synopsis": "dl_cosh dynlist_name | dl_cosh number",
    "brief": "Computes the element-wise hyperbolic cosine of a dynamic list or a single number. Returns a new list of floats.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float",
      "brief": "Resulting values are always >= 1.0."
    },
    "errors": [
      "TCL_ERROR if input list is not found or is a string list.",
      "TCL_ERROR for general math errors (e.g., overflow for large magnitude inputs)."
    ],
    "example": "set values [dl_create 0 1 -1 2.5]\nset cosh_values [dl_cosh $values] ;# cosh_values approx [1.0 1.543 1.543 6.132]\ndl_cosh 0 ;# Result is 1.0",
    "see_also": ["dl_sinh", "dl_tanh", "dl_cos"]
  },
  {
    "command": "dl_countOccurences",
    "category": "Searching / Counting",
    "synopsis": "dl_countOccurences source_dynlist_name search_item_name_or_value",
    "brief": "Counts the number of non-overlapping occurrences of a search item (which can be a dynlist or a literal value) within a source dynlist.",
    "inputs": {
      "type": "varied",
      "length": 2,
      "element_types": ["string (source_dynlist_name)", "string_or_value (search_item_name_or_value)"],
      "constraints": "The 'source_dynlist' can be of any type. The 'search_item' will be compared element-wise if it's a list, or as a single value. If 'search_item' is a list, its elements must be comparable to the elements of 'source_dynlist'."
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "The total number of non-overlapping times the search_item is found in source_dynlist."
    },
    "errors": [
      "TCL_ERROR if source_dynlist_name or search_item_name (if provided as a list name) is not found.",
      "TCL_ERROR if types are incompatible for comparison.",
      "TCL_ERROR if the wrong number of arguments is provided (expects 2)."
    ],
    "example": "set mainList [dl_create 1 2 3 1 2 4 1 2 3 5]\nset subList [dl_create 1 2]\nset count1 [dl_countOccurences $mainList $subList]   ;# count1 will be 3\nset count2 [dl_countOccurences $mainList 3]          ;# count2 will be 2\n\nset strList [dl_slist apple banana apple orange apple]\nset count3 [dl_countOccurences $strList apple]     ;# count3 will be 3",
    "see_also": ["dl_find", "dl_findAll", "dl_findIndices", "dl_findPatterns"]
  },
  {
    "command": "dl_create",
    "category": "Creation",
    "synopsis": "dl_create [value1 value2 ... | {value_list} | dynlist_name1 dynlist_name2 ...]",
    "brief": "Creates a new dynamic list. The type of the list is inferred from the first value provided, or it may default if no values are given. Initializes with optional values.",
    "inputs": {
      "type": "varied (values, Tcl list, or dynlist names)",
      "length": "0+",
      "element_types": ["any (literal values)", "Tcl list of values", "string (dynlist_name)"],
      "constraints": "If multiple values or lists are provided, they should be compatible for forming a single typed list (e.g., all numbers, all strings, or types that can be promoted). If dynlist names are given, their elements are copied."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "any (inferred from input: integer, float, string, list, etc.)"
    },
    "errors": [
      "TCL_ERROR if provided values cannot be consistently typed or converted.",
      "TCL_ERROR if a named dynlist argument is not found or its elements are incompatible.",
      "TCL_ERROR if memory allocation fails."
    ],
    "example": "set list1 [dl_create]                   ;# Creates an empty list (type might be initially flexible or default)\nset list2 [dl_create 1 2 3]             ;# Creates an integer list: [1 2 3]\nset list3 [dl_create 1.0 2 3.5]         ;# Creates a float list: [1.0 2.0 3.5]\nset list4 [dl_create hello world]         ;# Creates a string list: [hello world]\nset list5 [dl_create {a b c}]           ;# Creates a string list: [a b c] (from Tcl list)\nset list6 [dl_create $list2 $list3]     ;# Creates a new list by copying elements from list2 then list3 (likely becomes float list)",
    "see_also": ["dl_ilist", "dl_flist", "dl_slist", "dl_llist", "dl_clist", "dl_append", "dl_delete"]
  },
  {
    "command": "dl_cumprod",
    "category": "Arithmetic / Accumulation",
    "synopsis": "dl_cumprod dynlist_name",
    "brief": "Computes the cumulative product of elements in a numeric dynamic list. Returns a new list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["numeric"],
      "constraints": "Input list must be numeric and 1D. Behavior for empty list might be an error or an empty list."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "numeric (promoted as necessary, e.g., to float to accommodate large products or float inputs)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found or is not a numeric list.",
      "TCL_ERROR if the list is empty (potentially).",
      "TCL_ERROR for numeric overflow if products become too large for the data type and are not handled by promotion to float."
    ],
    "example": "set myList [dl_create 1 2 3 4 0.5]\nset cProd [dl_cumprod $myList] ;# cProd will be [1.0 2.0 6.0 24.0 12.0]\n\nset another [dl_ilist 2 3 -1 5]\nset cProd2 [dl_cumprod $another] ;# cProd2 could be [2 6 -6 -30] (as integers or floats)",
    "see_also": ["dl_cumsum", "dl_prod", "dl_sum"]
  },
  {
    "command": "dl_cumsum",
    "category": "Arithmetic / Accumulation",
    "synopsis": "dl_cumsum dynlist_name",
    "brief": "Computes the cumulative sum of elements in a numeric dynamic list. Returns a new list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["numeric"],
      "constraints": "Input list must be numeric and 1D. Behavior for empty list might be an error or an empty list."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "numeric (promoted as necessary, e.g., to float to accommodate large sums or float inputs)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found or is not a numeric list.",
      "TCL_ERROR if the list is empty (potentially).",
      "TCL_ERROR for numeric overflow if sums become too large for the data type and are not handled by promotion to float."
    ],
    "example": "set myList [dl_create 1 2 3 4 -5.5]\nset cSum [dl_cumsum $myList] ;# cSum will be [1.0 3.0 6.0 10.0 4.5]\n\nset another [dl_ilist 10 20 -5 15]\nset cSum2 [dl_cumsum $another] ;# cSum2 could be [10 30 25 40] (as integers or floats)",
    "see_also": ["dl_cumprod", "dl_sum", "dl_prod"]
  },
  {
    "command": "dl_cycle",
    "category": "Manipulation / Permutation",
    "synopsis": "dl_cycle dynlist_name [shift_amount]",
    "brief": "Cycles the elements of a 1D dynamic list by a specified 'shift_amount'. Positive shifts right, negative shifts left. Elements wrap around. Default shift is 1. Returns a new list.",
    "inputs": {
      "type": "varied",
      "length": "1-2",
      "element_types": ["string (dynlist_name)", "integer (shift_amount, optional)"],
      "constraints": "Input list must be 1D. If 'shift_amount' is not provided, it defaults to 1."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "Same as input dynlist."
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found.",
      "TCL_ERROR if 'shift_amount' (if provided) is not an integer.",
      "TCL_ERROR if input list is not 1D (e.g. a list of lists)."
    ],
    "example": "set myList [dl_create a b c d e]\nset cycled1 [dl_cycle $myList]        ;# cycled1 is [e a b c d] (default shift 1)\nset cycled2 [dl_cycle $myList 2]      ;# cycled2 is [d e a b c]\nset cycled3 [dl_cycle $myList -1]     ;# cycled3 is [b c d e a]",
    "see_also": ["dl_shift", "dl_bcycle", "dl_bshift", "dl_permute", "dl_reverse"]
  },
  {
    "command": "dl_datatype",
    "category": "Introspection",
    "synopsis": "dl_datatype dynlist_name",
    "brief": "Returns a string representing the underlying data type of the specified dynamic list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["The name of an existing dynamic list."]
    },
    "returns": {
      "type": "string",
      "new_object": false,
      "brief": "A string identifier for the data type (e.g., \"DF_LONG\", \"DF_FLOAT\", \"DF_STRING\", \"DF_LIST\", \"DF_CHAR\")."
    },
    "errors": [
      "TCL_ERROR if dynlist_name does not refer to an existing dynamic list."
    ],
    "example": "set intList [dl_ilist 1 2 3]\nset type1 [dl_datatype $intList]    ;# type1 will be \"DF_LONG\" (or similar for integer)\n\nset floatList [dl_flist 1.0 2.5]\nset type2 [dl_datatype $floatList]  ;# type2 will be \"DF_FLOAT\" (or DF_DOUBLE)\n\nset stringList [dl_slist hello world]\nset type3 [dl_datatype $stringList] ;# type3 will be \"DF_STRING\"",
    "see_also": ["dl_exists", "dl_length", "dl_llength", "dl_depth", "dl_isMatrix"]
  },
  {
    "command": "dl_deep_pack",
    "category": "Serialization / Restructuring",
    "synopsis": "dl_deep_pack list_of_lists_name",
    "brief": "Serializes a potentially nested list of lists into a flat binary dynamic list. This is useful for efficient storage or transmission and can be reversed using dl_deep_unpack.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["The name of an existing dynamic list, typically of type DF_LIST, containing potentially nested sublists."]
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "DF_BINARY (or DF_CHAR, containing a compact binary representation)",
      "brief": "The packed list contains information about the original structure and all its elements."
    },
    "errors": [
      "TCL_ERROR if list_of_lists_name is not found.",
      "TCL_ERROR if the input list is not a list of lists (DF_LIST) or cannot be packed for other reasons (e.g. unsupported element types for packing within sublists if very heterogeneous).",
      "TCL_ERROR for memory allocation failures during the packing process."
    ],
    "example": "set lol [dl_llist [dl_ilist 1 2] [dl_llist [dl_flist 3.0 4.0] [dl_slist foo]] [dl_ilist 5]]\nset packed_lol [dl_deep_pack $lol]\n# packed_lol is now a binary dynlist containing the serialized form of lol\n\n# To restore:\n# set restored_lol [dl_deep_unpack $packed_lol]",
    "see_also": ["dl_deep_unpack", "dl_pack", "dl_unpack", "dl_toString", "dl_fromString"]
  },
  {
    "command": "dl_deep_unpack",
    "category": "Serialization / Restructuring",
    "synopsis": "dl_deep_unpack packed_dynlist_name",
    "brief": "Reconstructs a potentially nested list of lists from a flat binary dynamic list that was created by dl_deep_pack.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["The name of an existing dynamic list of type DF_BINARY (or DF_CHAR) containing data previously serialized by dl_deep_pack."]
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "DF_LIST (reconstructing the original nested structure and element types)",
      "brief": "The new list is a deep copy of the original structure that was packed."
    },
    "errors": [
      "TCL_ERROR if packed_dynlist_name is not found.",
      "TCL_ERROR if the input list is not of type DF_BINARY/DF_CHAR or if its content is not a valid packed representation (e.g., corrupted data, incorrect format).",
      "TCL_ERROR for memory allocation failures during unpacking."
    ],
    "example": "# Assume packed_lol was created by: set packed_lol [dl_deep_pack $some_list_of_lists]\nset unpacked_lol [dl_deep_unpack $packed_lol]\n# unpacked_lol is now a new list of lists, identical in structure and content to $some_list_of_lists",
    "see_also": ["dl_deep_pack", "dl_unpack", "dl_pack", "dl_fromString", "dl_toString"]
  },
  {
    "command": "dl_delete",
    "category": "Memory Management",
    "synopsis": "dl_delete dynlist_name1 [dynlist_name2 ...]",
    "brief": "Deletes one or more specified dynamic lists from memory.",
    "inputs": {
      "type": "strings (dynlist_names)",
      "length": "1+",
      "element_types": ["string (name of an existing dynamic list)"],
      "constraints": "At least one dynlist name must be provided."
    },
    "returns": {
      "type": "void (TCL_OK on success)",
      "new_object": false
    },
    "side_effects": [
      "The specified dynamic lists are deallocated and their names are removed from the interpreter's list registry."
    ],
    "errors": [
      "TCL_ERROR if no dynlist names are provided.",
      "TCL_ERROR if any specified dynlist_name is not found (unless a -nocomplain option is supported and used, which is not assumed here)."
    ],
    "example": "set myList1 [dl_create 1 2 3]\nset myList2 [dl_slist a b c]\ndl_delete $myList1 $myList2 ;# Both myList1 and myList2 are deleted\n# dl_exists $myList1 ;# would return 0",
    "see_also": ["dl_clean", "dl_cleanReturns", "dg_delete", "dl_reset"]
  },
  {
    "command": "dl_deleteTrace",
    "category": "Introspection / Tracing",
    "synopsis": "dl_deleteTrace dynlist_name trace_id",
    "brief": "Removes a previously set trace from a dynamic list. The trace_id is typically returned by the command that set the trace.",
    "inputs": {
      "type": "varied",
      "length": 2,
      "element_types": ["string (dynlist_name)", "string_or_integer (trace_id)"],
      "constraints": "'dynlist_name' must refer to an existing dynamic list that has an active trace matching 'trace_id'."
    },
    "returns": {
      "type": "void (TCL_OK on success)",
      "new_object": false
    },
    "side_effects": [
      "The specified trace is removed from the dynamic list. The associated Tcl script/command will no longer execute when traced operations occur."
    ],
    "errors": [
      "TCL_ERROR if dynlist_name is not found.",
      "TCL_ERROR if trace_id is invalid, not found for the given list, or does not correspond to an active trace.",
      "TCL_ERROR if the dynamic list is not a traced variable or if there are internal issues with trace management."
    ],
    "example": "# Assuming 'myList' has a trace with id 'trace123' (e.g., set by a hypothetical 'dl_addTrace')\n# proc my_trace_proc {args} { puts \"Trace fired: $args\" }\n# set tr_id [dl_addTrace myList {write read} my_trace_proc] ;# hypothetical\n# dl_append myList 1 ;# Fires trace\n# dl_deleteTrace myList $tr_id\n# dl_append myList 2 ;# Does NOT fire trace anymore",
    "see_also": ["dl_traceVariable (hypothetical)", "Tcl built-in 'trace' command"]
  },
  {
    "command": "dl_depth",
    "category": "Introspection",
    "synopsis": "dl_depth dynlist_name",
    "brief": "Returns the maximum nesting depth of a dynamic list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["The name of an existing dynamic list."]
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "Depth: 1 for a simple list, 2 for a list of simple lists, etc. An empty list (e.g. from dl_create) has depth 1. An empty list of lists (e.g. from dl_llist) has depth 2."
    },
    "errors": [
      "TCL_ERROR if dynlist_name does not refer to an existing dynamic list."
    ],
    "example": "set l1 [dl_create 1 2 3]              ;# depth 1\nset depth1 [dl_depth $l1]\n\nset l2 [dl_llist $l1 [dl_create 4 5]]  ;# depth 2 (list of simple lists)\nset depth2 [dl_depth $l2]\n\nset l3 [dl_llist $l2 [dl_llist [dl_create 6]]] ;# depth 3 (list of lists of lists)\nset depth3 [dl_depth $l3]\n\nset empty1 [dl_create]                   ;# depth 1\nset depth_e1 [dl_depth $empty1]\n\nset empty2 [dl_llist]                    ;# depth 2 (it's a DF_LIST, intended to hold lists)\nset depth_e2 [dl_depth $empty2]",
    "see_also": ["dl_datatype", "dl_length", "dl_llength", "dl_isMatrix"]
  },
  {
    "command": "dl_diff",
    "category": "Arithmetic / Data Analysis",
    "synopsis": "dl_diff dynlist_name [lag]",
    "brief": "Computes the element-wise difference between lagged elements of a numeric dynamic list (list[i+lag] - list[i]). Returns a new list.",
    "inputs": {
      "type": "varied",
      "length": "1-2",
      "element_types": ["string (dynlist_name)", "integer (lag, optional)"],
      "constraints": "Input list must be numeric and 1D. 'lag' must be a positive integer, defaults to 1 if omitted. List length must be greater than lag."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "numeric (promoted as necessary, e.g., to float)",
      "brief": "The resulting list will be shorter than the input list by 'lag' elements."
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found or is not a numeric list.",
      "TCL_ERROR if 'lag' is not a positive integer.",
      "TCL_ERROR if list length is not greater than 'lag'."
    ],
    "example": "set myList [dl_create 1 3 6 10 12.5]\nset diff1 [dl_diff $myList]        ;# lag=1, diff1 is [2.0 3.0 4.0 2.5]\nset diff2 [dl_diff $myList 2]    ;# lag=2, diff2 is [5.0 7.0 6.5]\n\nset intList [dl_ilist 10 20 25 30 40]\nset diff_int [dl_diff $intList]    ;# diff_int is [10 5 5 10]",
    "see_also": ["dl_idiff", "dl_sub", "dl_cumsum"]
  },
  {
    "command": "dl_dir",
    "category": "Introspection / Registry",
    "synopsis": "dl_dir [pattern]",
    "brief": "Returns a Tcl list of names of all currently defined dynamic lists. An optional glob pattern can be provided to filter the names.",
    "inputs": {
      "type": "string (pattern, optional)",
      "length": "0-1",
      "element_types": ["string (glob pattern)"],
      "constraints": "If provided, 'pattern' is used to filter the list names (e.g., \"%*\" for temporary lists)."
    },
    "returns": {
      "type": "TclList (of strings)",
      "new_object": true,
      "element_type": "string (dynlist name)",
      "brief": "A Tcl list where each element is the name of a dynamic list. The order is typically the order of creation or internal hash order."
    },
    "errors": [
      "TCL_ERROR if there is an issue accessing the dynamic list registry (very unlikely)."
    ],
    "example": "set a [dl_create 1]\nset b [dl_slist x y]\nset c [dl_ilist 10 20]\ndl_dir                 ;# Returns a Tcl list like: {a b c} (or %list0 %list1 %list2 if they got temp names)\ndl_dir %*              ;# Might return names of temporary lists if any exist and were not assigned to variables.",
    "see_also": ["dg_dir", "dl_exists", "dl_clean"]
  },
  {
    "command": "dl_div",
    "category": "Arithmetic",
    "synopsis": "dl_div dividend_list_or_val divisor_list_or_val [divisor2_list_or_val ...]",
    "brief": "Performs element-wise division. The dividend is divided by the first divisor, then the result by the second divisor, and so on. Returns a new list, typically of floats.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": "2+",
      "element_types": ["numeric"],
      "constraints": "Inputs must be numeric and broadcastable (e.g., same length or one is a scalar/1-element list). All divisor elements must be non-zero."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float (typically, to handle non-integer results and promote precision)"
    },
    "errors": [
      "TCL_ERROR if any input list is not found or not numeric.",
      "TCL_ERROR if lists are not compatible for division (cannot be broadcast).",
      "TCL_ERROR if division by zero is attempted for any element."
    ],
    "example": "set l1 [dl_create 10 20 30.0]\nset l2 [dl_create 2 5 2.0]\nset l3 [dl_div $l1 $l2]      ;# l3 is [5.0 4.0 15.0]\nset l4 [dl_div $l1 2]        ;# l4 is [5.0 10.0 15.0] (l1 divided by scalar 2)\nset l5 [dl_create 100]\nset l6 [dl_div $l5 $l1 $l2] ;# l6: (100/10)/2=5, (100/20)/5=1, (100/30)/2=1.666...",
    "see_also": ["dl_add", "dl_sub", "dl_mult", "dl_recip"]
  },
  {
    "command": "dl_dotimes",
    "category": "Control Structure",
    "synopsis": "dl_dotimes varName count_or_dynlist scriptBody",
    "brief": "A loop construct similar to Tcl's dotimes. Iterates 'scriptBody' a specified number of times, setting 'varName' to the current iteration index (0 to N-1). If 'count_or_dynlist' is a dynlist name, N is its length.",
    "inputs": {
      "type": "varied",
      "length": "3",
      "element_types": ["string (varName)", "integer_or_string (count_or_dynlist_name)", "string (scriptBody)"],
      "constraints": "'varName' is the iterator variable. 'count_or_dynlist_name' must be a non-negative integer or the name of an existing dynlist. 'scriptBody' is a Tcl script."
    },
    "returns": {
      "type": "string",
      "new_object": false,
      "brief": "The result of the last command executed in 'scriptBody' in the final iteration, or an empty string if the loop doesn't execute or 'scriptBody' is empty."
    },
    "side_effects": [
      "The variable 'varName' is set to the current iteration index (0-based) within the scope of 'scriptBody'.",
      "'scriptBody' is executed N times, potentially causing any Tcl side effects."
    ],
    "errors": [
      "TCL_ERROR if 'count_or_dynlist_name' is a dynlist name that is not found.",
      "TCL_ERROR if 'count_or_dynlist_name' does not evaluate to a non-negative integer (if not a dynlist name).",
      "TCL_ERROR if 'scriptBody' is syntactically incorrect.",
      "Errors from within the 'scriptBody' execution will propagate."
    ],
    "example": "set myList [dl_create a b c]\nset resultList [dl_create]\ndl_dotimes idx $myList {\n  dl_append $resultList [format \"Index: %d, Value: %[dl_get $myList $idx]%\"]\n}\n# resultList might contain: {\"Index: 0, Value: a\" \"Index: 1, Value: b\" \"Index: 2, Value: c\"}\n\ndl_dotimes i 3 { puts \"Iteration $i\" } ;# Prints Iteration 0, Iteration 1, Iteration 2",
    "see_also": ["dl_foreach", "Tcl built-in 'for'", "Tcl built-in 'while'", "Tcl built-in 'dotimes'"]
  },
  {
    "command": "dl_dump",
    "category": "Introspection / Debugging",
    "synopsis": "dl_dump dynlist_name [channelId]",
    "brief": "Prints the contents of a dynamic list to the specified Tcl channel or stdout. Useful for debugging.",
    "inputs": {
      "type": "varied",
      "length": "1-2",
      "element_types": ["string (dynlist_name)", "string (channelId, optional)"],
      "constraints": "'dynlist_name' must be an existing dynamic list. If 'channelId' is provided, it must be a valid writable Tcl channel (e.g., stdout, stderr, or a file channel). Defaults to stdout."
    },
    "returns": {
      "type": "void (TCL_OK on success)",
      "new_object": false
    },
    "side_effects": [
      "The contents of the dynamic list are printed to the specified channel or stdout.",
      "The output format depends on the list's data type and structure (e.g., numbers space-separated, strings possibly quoted, nested lists shown with braces)."
    ],
    "errors": [
      "TCL_ERROR if dynlist_name is not found.",
      "TCL_ERROR if channelId is provided but is not a valid writable Tcl channel."
    ],
    "example": "set myList [dl_create 1.0 2.5 -3.0]\ndl_dump $myList            ;# Prints to stdout, e.g., \"1.0 2.5 -3.0\n\"\n\nset myStrings [dl_slist hello \"world with spaces\"]\ndl_dump $myStrings         ;# Prints to stdout, e.g., {hello} {world with spaces}\n\nset f [open output.txt w]\ndl_dump $myList $f\nclose $f",
    "see_also": ["dg_dump", "dl_write", "dl_toString", "dl_get"]
  },
  {
    "command": "dl_dumpAsRow",
    "category": "Introspection / Debugging / Formatting",
    "synopsis": "dl_dumpAsRow dynlist_name [channelId] [delimiter]",
    "brief": "Prints the elements of a 1D dynamic list as a single row to a channel (default stdout), using an optional delimiter (default space).",
    "inputs": {
      "type": "varied",
      "length": "1-3",
      "element_types": ["string (dynlist_name)", "string (channelId, optional)", "string (delimiter, optional)"],
      "constraints": "'dynlist_name' must be an existing 1D dynamic list. 'channelId' defaults to stdout. 'delimiter' defaults to a single space."
    },
    "returns": {
      "type": "void (TCL_OK on success)",
      "new_object": false
    },
    "side_effects": [
      "Prints the list elements as a single line, separated by the delimiter, followed by a newline, to the specified channel."
    ],
    "errors": [
      "TCL_ERROR if dynlist_name is not found or is not a 1D list.",
      "TCL_ERROR if channelId is invalid."
    ],
    "example": "set rowData [dl_create 10 20 30 40]\ndl_dumpAsRow $rowData                ;# Prints to stdout: \"10 20 30 40\n\"\ndl_dumpAsRow $rowData stdout \",\"   ;# Prints to stdout: \"10,20,30,40\n\"\n\nset f [open row_output.txt w]\ndl_dumpAsRow $rowData $f \"\t\"    ;# Writes tab-separated values to file\nclose $f",
    "see_also": ["dl_dump", "dl_dumpMatrix", "dl_dumpMatrixInCols", "dl_writeAs"]
  },
  {
    "command": "dl_dumpMatrix",
    "category": "Introspection / Debugging / Formatting",
    "synopsis": "dl_dumpMatrix matrix_dynlist_name [channelId] [col_delimiter] [row_prefix] [row_suffix]",
    "brief": "Prints a 2D dynamic list (list of lists) in a matrix format to a channel (default stdout).",
    "inputs": {
      "type": "varied",
      "length": "1-5",
      "element_types": [
        "string (matrix_dynlist_name)",
        "string (channelId, optional)",
        "string (col_delimiter, optional)",
        "string (row_prefix, optional)",
        "string (row_suffix, optional)"
      ],
      "constraints": "'matrix_dynlist_name' must be a list of 1D lists (a 2D matrix). 'channelId' defaults to stdout. 'col_delimiter' defaults to space. 'row_prefix' and 'row_suffix' default to empty strings but can be e.g. '{' and '}'."
    },
    "returns": {
      "type": "void (TCL_OK on success)",
      "new_object": false
    },
    "side_effects": [
      "Prints the matrix row by row. Each row is prefixed by 'row_prefix', elements are separated by 'col_delimiter', and suffixed by 'row_suffix', followed by a newline."
    ],
    "errors": [
      "TCL_ERROR if matrix_dynlist_name is not found or is not a 2D list (list of 1D lists).",
      "TCL_ERROR if sublists are not 1D or have incompatible types for consistent printing.",
      "TCL_ERROR if channelId is invalid."
    ],
    "example": "set matrix [dl_llist [dl_create 1 2 3] [dl_create 4 5 6] [dl_create 7 8 9]]\ndl_dumpMatrix $matrix                        ;# Default: prints space separated, newlines between rows\n# Output:\n# 1 2 3\n# 4 5 6\n# 7 8 9\n\ndl_dumpMatrix $matrix stdout \",\" \"{\" \"}\"   ;# Prints CSV-like with braces\n# Output:\n# {1,2,3}\n# {4,5,6}\n# {7,8,9}",
    "see_also": ["dl_dump", "dl_dumpAsRow", "dl_dumpMatrixInCols", "dl_isMatrix"]
  },
  {
    "command": "dl_dumpMatrixInCols",
    "category": "Introspection / Debugging / Formatting",
    "synopsis": "dl_dumpMatrixInCols matrix_dynlist_name [channelId] [col_delimiter] [options...]",
    "brief": "Prints a 2D dynamic list (matrix) to a channel (default stdout) with elements aligned in columns. Assumes sublists (rows) have equal length.",
    "inputs": {
      "type": "varied",
      "length": "1+",
      "element_types": [
        "string (matrix_dynlist_name)",
        "string (channelId, optional)",
        "string (col_delimiter, optional)",
        "string (various_options_for_formatting, optional)"
      ],
      "constraints": "'matrix_dynlist_name' must be a list of 1D lists with equal lengths. 'channelId' defaults to stdout. 'col_delimiter' defaults to one or more spaces for alignment. Options might control padding, justification etc."
    },
    "returns": {
      "type": "void (TCL_OK on success)",
      "new_object": false
    },
    "side_effects": [
      "Prints the matrix with elements formatted into aligned columns. Each row of the input matrix corresponds to a line of output."
    ],
    "errors": [
      "TCL_ERROR if matrix_dynlist_name is not found or is not a 2D list.",
      "TCL_ERROR if sublists (rows) have inconsistent lengths, making columnar display ambiguous.",
      "TCL_ERROR if channelId is invalid.",
      "TCL_ERROR for invalid formatting options."
    ],
    "example": "set m [dl_llist [dl_slist Name Age City] [dl_slist Alice 30 London] [dl_slist Bob 24 Paris] [dl_slist Charles 45 Berlin]]\ndl_dumpMatrixInCols $m stdout \"  \" ;# Use two spaces as delimiter for potential padding\n# Expected Output (actual spacing depends on implementation):\n# Name     Age  City  \n# Alice    30   London\n# Bob      24   Paris \n# Charles  45   Berlin",
    "see_also": ["dl_dumpMatrix", "dl_dumpAsRow", "dl_transpose"]
  },
  {
    "command": "dl_eq",
    "category": "Logical / Comparison",
    "synopsis": "dl_eq list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise equality (==) comparison. If more than two arguments, it checks chained equality (e.g., a==b AND b==c). Returns a new list of 0s (false) and 1s (true).",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable (Tcl's comparison rules apply, which can be flexible with types)."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "Result contains 0 (false) or 1 (true) for each element-wise comparison."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists are not compatible for comparison (cannot be broadcast)."
    ],
    "example": "set l1 [dl_create 1 2 3 2 5]\nset l2 [dl_create 1 2 4 2 0]\nset res1 [dl_eq $l1 $l2]   ;# res1 is [1 1 0 1 0]\nset res2 [dl_eq $l1 2]     ;# res2 is [0 1 0 1 0] (l1 compared to scalar 2)\n\nset s1 [dl_slist a b c]\nset s2 [dl_slist a d c]\nset res3 [dl_eq $s1 $s2]   ;# res3 is [1 0 1]\n\nset l3 [dl_create 2 2 2]\nset res4 [dl_eq $l1 $l3 2] ;# res4 (l1==l3 and l3==2) is [0 1 0 1 0] AND [1 1 1] broadcast with 2 -> [0 1 0 0 0] (assuming strict element-wise for chained)",
    "see_also": ["dl_noteq", "dl_gt", "dl_lt", "dl_gte", "dl_lte", "dl_and", "dl_or"]
  },
  {
    "command": "dl_eqIndex",
    "category": "Logical / Comparison / Indexing",
    "synopsis": "dl_eqIndex list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise equality (==) comparison and returns a new list containing the 0-based indices where the result is true. If more than two arguments, it checks chained equality.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable (Tcl's comparison rules apply)."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 0-based indices where the comparison is true."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists are not compatible for comparison (cannot be broadcast)."
    ],
    "example": "set l1 [dl_create 10 20 30 20 10]\nset l2 [dl_create 10 25 30 20 15]\nset idx1 [dl_eqIndex $l1 $l2]  ;# idx1 is [0 2 3]\nset idx2 [dl_eqIndex $l1 20]  ;# idx2 is [1 3]\n\nset s1 [dl_slist x y z y x]\nset s2 [dl_slist x a z y k]\nset idx3 [dl_eqIndex $s1 $s2]  ;# idx3 is [0 2 3]\n\nset l3 [dl_create 20 20 20]\nset idx4 [dl_eqIndex $l1 $l3 20] ;# (l1==l3 AND l3==20). l1==l3 -> [0 1 0 1 0] (after broadcast). l3==20 -> [1 1 1]. Resulting indices from [0 1 0 1 0] AND ([1 1 1] broadcasted) -> indices where both are true for $l1: [1 3]",
    "see_also": ["dl_eq", "dl_noteqIndex", "dl_gtIndex", "dl_ltIndex", "dl_andIndex", "dl_orIndex", "dl_select"]
  },
  {
    "command": "dl_exists",
    "category": "Introspection / Registry",
    "synopsis": "dl_exists dynlist_name",
    "brief": "Checks if a dynamic list with the specified name exists in the current interpreter.",
    "inputs": {
      "type": "string",
      "length": 1,
      "element_types": ["string (dynlist_name)"],
      "constraints": "'dynlist_name' is the name to check for existence."
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "Returns 1 if the dynamic list exists, 0 otherwise."
    },
    "errors": [
      "TCL_ERROR if the wrong number of arguments is provided (expects exactly one argument)."
    ],
    "example": "set myList [dl_create 1 2 3]\nif {[dl_exists $myList]} {\n  puts \"myList exists!\"\n} else {\n  puts \"myList does not exist.\"\n}\n# Output: myList exists!\n\ndl_delete $myList\nputs [dl_exists $myList] ;# Output: 0\n\nputs [dl_exists some_nonexistent_list] ;# Output: 0",
    "see_also": ["dg_exists", "dl_dir", "dl_datatype", "dl_delete"]
  },
  {
    "command": "dl_exp",
    "category": "Arithmetic / Transcendental",
    "synopsis": "dl_exp dynlist_name | dl_exp number",
    "brief": "Computes the element-wise natural exponential (e^x) of a dynamic list or a single number. Returns a new list of floats.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float"
    },
    "errors": [
      "TCL_ERROR if input list is not found or is a string list.",
      "TCL_ERROR for math errors such as overflow for large input values."
    ],
    "example": "set values [dl_create 0 1 2 -1 0.5]\nset exp_values [dl_exp $values] ;# exp_values approx [1.0 2.718 7.389 0.367 1.648]\ndl_exp 3 ;# Returns a new list containing e^3 (approx 20.085)",
    "see_also": ["dl_log", "dl_log10", "dl_pow", "dl_sqrt"]
  },
  {
    "command": "dl_fill",
    "category": "Creation",
    "synopsis": "dl_fill count value [-type type_string]",
    "brief": "Creates a new dynamic list of 'count' elements, all initialized to 'value'. An optional type can be specified.",
    "inputs": {
      "type": "varied",
      "length": "2-4",
      "element_types": ["integer (count)", "any (value)", "string (-type, optional literal)", "string (type_string, e.g. int, float, string, optional)"],
      "constraints": "'count' must be a non-negative integer. 'value' is the fill value. If '-type' is used, 'type_string' specifies the list type; otherwise, type is inferred from 'value'."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "any (matches 'value' type or specified by '-type')"
    },
    "errors": [
      "TCL_ERROR if 'count' is not a non-negative integer.",
      "TCL_ERROR if 'value' cannot be converted/used for the specified or inferred type.",
      "TCL_ERROR if an invalid 'type_string' is provided with '-type'.",
      "TCL_ERROR for incorrect number of arguments."
    ],
    "example": "set list1 [dl_fill 5 0]          ;# list1 is an integer list: [0 0 0 0 0]\nset list2 [dl_fill 3 1.2]        ;# list2 is a float list: [1.2 1.2 1.2]\nset list3 [dl_fill 4 hello -type string] ;# list3 is a string list: [hello hello hello hello]\nset list4 [dl_fill 2 true -type int] ;# list4 might be [1 1] if true converts to 1 for int type",
    "see_also": ["dl_create", "dl_zeros", "dl_ones", "dl_repeat"]
  },
  {
    "command": "dl_find",
    "category": "Searching",
    "synopsis": "dl_find source_dynlist_name search_item_name_or_value [start_index]",
    "brief": "Finds the first occurrence of a search item (sublist or value) within a source dynamic list. Returns the 0-based starting index or -1 if not found.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["string (source_dynlist_name)", "string_or_any (search_item_name_or_value)", "integer (start_index, optional)"],
      "constraints": "'search_item_name_or_value' can be a dynlist name or a literal value. 'start_index' defaults to 0."
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "0-based index of the first match, or -1 if not found."
    },
    "errors": [
      "TCL_ERROR if source_dynlist or search_item (if a list name) is not found.",
      "TCL_ERROR if start_index is not a valid integer or is out of bounds.",
      "TCL_ERROR if types are incompatible for comparison."
    ],
    "example": "set mainList [dl_create a b c a b d e]\nset subList [dl_create a b]\nset idx1 [dl_find $mainList $subList]       ;# idx1 is 0\nset idx2 [dl_find $mainList $subList 1]     ;# idx2 is 3 (starts search from index 1)\nset idx3 [dl_find $mainList c]             ;# idx3 is 2\nset idx4 [dl_find $mainList x]             ;# idx4 is -1 (not found)\\n\\nset numList [dl_ilist 10 20 30 10 20 40]\nset searchNums [dl_ilist 10 20]\nset idx5 [dl_find $numList $searchNums]   ;# idx5 is 0\nset idx6 [dl_find $numList 30 1]         ;# idx6 is 2",
    "see_also": ["dl_findAll", "dl_findIndices", "dl_countOccurences", "dl_firstPos", "dl_stringmatch"]
  },
  {
    "command": "dl_findAll",
    "category": "Searching",
    "synopsis": "dl_findAll source_dynlist_name search_item_name_or_value [start_index]",
    "brief": "Finds all non-overlapping occurrences of a search item (sublist or value) within a source dynamic list. Returns a new list of 0-based starting indices.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["string (source_dynlist_name)", "string_or_any (search_item_name_or_value)", "integer (start_index, optional)"],
      "constraints": "'search_item_name_or_value' can be a dynlist name or a literal value. 'start_index' defaults to 0."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A new list of 0-based indices of all non-overlapping matches. Empty list if no matches found."
    },
    "errors": [
      "TCL_ERROR if source_dynlist or search_item (if a list name) is not found.",
      "TCL_ERROR if start_index is not a valid integer or is out of bounds.",
      "TCL_ERROR if types are incompatible for comparison."
    ],
    "example": "set mainList [dl_create a b c a b d a b c e]\nset subList [dl_create a b]\nset indices1 [dl_findAll $mainList $subList]    ;# indices1 is [0 3 6]\nset indices2 [dl_findAll $mainList $subList 1]  ;# indices2 is [3 6]\nset indices3 [dl_findAll $mainList c]          ;# indices3 is [2 8]\nset indices4 [dl_findAll $mainList x]          ;# indices4 is [] (empty list)",
    "see_also": ["dl_find", "dl_findIndices", "dl_countOccurences", "dl_regexp"]
  },
  {
    "command": "dl_findIndices",
    "category": "Searching / Indexing",
    "synopsis": "dl_findIndices source_dynlist_name search_item_name_or_value [start_index] [-all]",
    "brief": "Finds occurrences of a search item (sublist or value) within a source dynamic list and returns their 0-based starting indices. By default, finds all non-overlapping occurrences.",
    "inputs": {
      "type": "varied",
      "length": "2-4",
      "element_types": ["string (source_dynlist_name)", "string_or_any (search_item_name_or_value)", "integer (start_index, optional)", "string (-all, optional literal flag)"],
      "constraints": "'search_item_name_or_value' can be a dynlist name or a literal. 'start_index' defaults to 0. The '-all' flag is often implied if not other mode specified."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A new list of 0-based indices. Typically all non-overlapping matches. Behavior might vary if other mode flags were supported (e.g. -first)."
    },
    "errors": [
      "TCL_ERROR if source_dynlist or search_item (if a list name) is not found.",
      "TCL_ERROR if start_index is not a valid integer or is out of bounds.",
      "TCL_ERROR if types are incompatible for comparison or invalid option provided."
    ],
    "example": "set data [dl_slist apple pear banana apple grape apple orange]\nset query apple\nset all_idx [dl_findIndices $data $query]          ;# all_idx is [0 3 5]\nset from_two [dl_findIndices $data $query 2]     ;# from_two is [3 5]\n\nset list_q [dl_slist grape apple]\nset found_list_idx [dl_findIndices $data $list_q] ;# found_list_idx is [4]",
    "see_also": ["dl_find", "dl_findAll", "dl_countOccurences", "dl_regexp", "dl_select"]
  },
  {
    "command": "dl_findPatterns",
    "category": "Searching / Regular Expressions",
    "synopsis": "dl_findPatterns source_dynlist_name regexp_pattern [regexp_options...]",
    "brief": "Finds elements in a string dynamic list that match a Tcl regular expression. Returns a list of 0-based indices of matching elements.",
    "inputs": {
      "type": "varied",
      "length": "2+",
      "element_types": ["string (source_dynlist_name)", "string (regexp_pattern)", "string (regexp_option, optional) ..."],
      "constraints": "'source_dynlist_name' should contain string elements. 'regexp_pattern' is a Tcl regular expression. Supported 'regexp_options' are those compatible with Tcl's regexp command when used for matching elements (e.g., -nocase)."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A new list of 0-based indices of elements in source_dynlist that matched the pattern. Empty if no matches."
    },
    "errors": [
      "TCL_ERROR if source_dynlist is not found or its elements are not strings.",
      "TCL_ERROR if regexp_pattern is invalid.",
      "TCL_ERROR for invalid regexp_options."
    ],
    "example": "set myStrings [dl_slist Apple Pears Banana Apricot GRAPE]\nset pattern {^[Aa].*} ;# Starts with A or a\nset matching_indices [dl_findPatterns $myStrings $pattern] ;# matching_indices is [0 3]\n\nset pattern2 {GRA.E}\nset case_sensitive_idx [dl_findPatterns $myStrings $pattern2]      ;# case_sensitive_idx is [4]\nset case_insensitive_idx [dl_findPatterns $myStrings $pattern2 -nocase] ;# case_insensitive_idx is [4] (assuming GRAPE is the only match)\\n\\nset files [dl_slist file1.txt data.csv image.png script.tcl notes.TXT]\nset txt_pattern {\\\\.txt$} ;# Escaped dot for literal dot, then end of string\nset txt_indices [dl_findPatterns $files $txt_pattern -nocase] ;# txt_indices is [0 4]",
    "see_also": ["dl_regexp", "dl_stringmatch", "dl_find", "dl_findAll", "Tcl built-in regexp"]
  },
  {
    "command": "dl_first",
    "category": "Accessing Elements",
    "synopsis": "dl_first dynlist_name",
    "brief": "Returns the first element of a dynamic list. If the list is a list of lists, it returns the name of the first sublist.",
    "inputs": {
      "type": "string",
      "length": 1,
      "element_types": ["string (dynlist_name)"],
      "constraints": "The dynamic list must not be empty."
    },
    "returns": {
      "type": "any_or_string (dynlist_name)",
      "new_object": false,
      "brief": "The first element of the list, or the name of the first sublist if it's a list of lists."
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found.",
      "TCL_ERROR if the list is empty.",
      "TCL_ERROR if the wrong number of arguments is provided."
    ],
    "example": "set myList [dl_create apple banana cherry]\nset first_item [dl_first $myList]   ;# first_item is \"apple\"\n\nset myNums [dl_ilist 10 20 30]\nset first_num [dl_first $myNums]     ;# first_num is 10\n\nset sub1 [dl_create 1 2]\nset sub2 [dl_create 3 4]\nset lol [dl_llist $sub1 $sub2]\nset first_sublist_name [dl_first $lol] ;# first_sublist_name is the name of sub1 (e.g., %list0)",
    "see_also": ["dl_last", "dl_get", "dl_index", "dl_pickone"]
  },
  {
    "command": "dl_firstPos",
    "category": "Searching / Indexing",
    "synopsis": "dl_firstPos dynlist_name value_to_find [start_index]",
    "brief": "Returns the 0-based index of the first occurrence of a specific 'value_to_find' in a dynamic list. Returns -1 if not found.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["string (dynlist_name)", "any (value_to_find)", "integer (start_index, optional)"],
      "constraints": "'value_to_find' must be a literal value comparable with list elements. 'start_index' defaults to 0."
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "0-based index of the first occurrence of the value, or -1 if not found."
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found.",
      "TCL_ERROR if start_index is invalid (e.g., out of bounds, not an integer).",
      "TCL_ERROR if value_to_find cannot be compared with list elements."
    ],
    "example": "set myList [dl_create a b c a b d a b c e]\nset pos1 [dl_firstPos $myList a]          ;# pos1 is 0\nset pos2 [dl_firstPos $myList a 1]        ;# pos2 is 3 (starts search from index 1)\nset pos3 [dl_firstPos $myList c]          ;# pos3 is 2\nset pos4 [dl_firstPos $myList x]          ;# pos4 is -1\\n\\nset myNums [dl_ilist 10 20 10 30 10]\nset num_pos1 [dl_firstPos $myNums 10]     ;# num_pos1 is 0\nset num_pos2 [dl_firstPos $myNums 10 1]   ;# num_pos2 is 2",
    "see_also": ["dl_find", "dl_findAll", "dl_lastPos", "dl_index"]
  },
  {
    "command": "dl_first_index_list",
    "category": "Searching / Indexing",
    "synopsis": "dl_first_index_list source_dynlist_name search_values_dynlist_name [start_index]",
    "brief": "Finds the 0-based index of the first element in 'source_dynlist' that matches any value present in 'search_values_dynlist'. Returns -1 if no match found.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["string (source_dynlist_name)", "string (search_values_dynlist_name)", "integer (start_index, optional)"],
      "constraints": "Both inputs must be valid dynlist names. 'start_index' defaults to 0."
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "0-based index in source_dynlist of the first match, or -1."
    },
    "errors": [
      "TCL_ERROR if source_dynlist_name or search_values_dynlist_name not found.",
      "TCL_ERROR if start_index is invalid.",
      "TCL_ERROR if elements are not comparable between lists."
    ],
    "example": "set sourceList [dl_slist a b c d e f c a g]\nset searchFor [dl_slist x c e z]\nset first_idx [dl_first_index_list $sourceList $searchFor]    ;# first_idx is 2 (due to 'c')\nset first_idx_from_3 [dl_first_index_list $sourceList $searchFor 3] ;# first_idx_from_3 is 4 (due to 'e', search started after 'c' at index 2)\\n\\nset emptySearch [dl_slist k l m]\nset no_match_idx [dl_first_index_list $sourceList $emptySearch] ;# no_match_idx is -1",
    "see_also": ["dl_find", "dl_firstPos", "dl_index_list", "dl_oneof"]
  },
  {
    "command": "dl_flist",
    "category": "Creation",
    "synopsis": "dl_flist [value1 value2 ... | {value_list} | dynlist_name1 dynlist_name2 ...]",
    "brief": "Creates a new dynamic list of type float (double precision). Initializes with optional values, converting them to floats.",
    "inputs": {
      "type": "varied (numeric values, Tcl list, or dynlist names)",
      "length": "0+",
      "element_types": ["numeric (value_to_convert_to_float)", "Tcl list of numeric values", "string (dynlist_name_of_numeric_list)"],
      "constraints": "All inputs will be converted to float. Non-numeric inputs will cause an error."
    },
    "returns": {
      "type": "string (name of new float DynList)",
      "new_object": true,
      "element_type": "float (double precision)"
    },
    "errors": [
      "TCL_ERROR if any input value cannot be converted to a float.",
      "TCL_ERROR if a named dynlist argument is not found or contains non-numeric data."
    ],
    "example": "set floatList1 [dl_flist 1 2.5 3]        ;# floatList1 is [1.0 2.5 3.0]\nset floatList2 [dl_flist {0.0 -1.1 5}]    ;# floatList2 is [0.0 -1.1 5.0]\nset intList [dl_ilist 10 20]\nset floatList3 [dl_flist $intList 30.3]  ;# floatList3 is [10.0 20.0 30.3]\nset emptyFloats [dl_flist]                ;# Creates an empty float list",
    "see_also": ["dl_create", "dl_ilist", "dl_slist", "dl_clist", "dl_llist", "dl_float"]
  },
  {
    "command": "dl_float",
    "category": "Conversion / Creation",
    "synopsis": "dl_float source_data [output_var_name]",
    "brief": "Converts elements of 'source_data' (dynlist name, Tcl list, or literal values) to float type, returning a new float dynlist. Optionally stores the new list's name in 'output_var_name'.",
    "inputs": {
      "type": "varied",
      "length": "1-2",
      "element_types": ["string_or_list_or_values (source_data)", "string (output_var_name, optional)"],
      "constraints": "'source_data' can be a dynlist name, a Tcl list of numeric values, or individual numeric values. All inputs are converted to float."
    },
    "returns": {
      "type": "string (name of new float DynList)",
      "new_object": true,
      "element_type": "float (double precision)"
    },
    "side_effects": [
      "If 'output_var_name' is provided, the Tcl variable by that name is set to the name of the new float dynlist."
    ],
    "errors": [
      "TCL_ERROR if source_data contains values that cannot be converted to float.",
      "TCL_ERROR if source_data is a dynlist name that is not found.",
      "TCL_ERROR if output_var_name is invalid (if used)."
    ],
    "example": "set intList [dl_ilist 1 2 30]\nset floatList1 [dl_float $intList]            ;# floatList1 is [1.0 2.0 30.0]\\n\\ndl_float {5 6.6 7} newFloatListName          ;# newFloatListName holds name of [5.0 6.6 7.0]\nputs [dl_dump $newFloatListName]                ;# (dl_dump to verify contents if needed)\\n\\nset floatList2 [dl_float 100 101.5]           ;# floatList2 is [100.0 101.5]",
    "see_also": ["dl_flist", "dl_int", "dl_char", "dl_stringmatch", "dl_convert"]
  },
  {
    "command": "dl_floor",
    "category": "Arithmetic",
    "synopsis": "dl_floor dynlist_name | dl_floor number",
    "brief": "Computes the element-wise floor of a dynamic list or number (largest integer less than or equal to each value). Returns a new list.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer (or float representing an integer, e.g., 2.0)"
    },
    "errors": [
      "TCL_ERROR if input list is not found, is a string list, or for general math errors."
    ],
    "example": "set myList [dl_create 1.7 2.0 -3.2 4.99]\nset floorList [dl_floor $myList] ;# floorList will be [1.0 2.0 -4.0 4.0] (or integer equivalents)\ndl_floor -5.5 ;# returns a new list containing [-6.0]",
    "see_also": ["dl_ceil", "dl_round", "dl_int", "dl_trunc"]
  },
  {
    "command": "dl_fmod",
    "category": "Arithmetic",
    "synopsis": "dl_fmod dividend_list_or_val divisor_list_or_val",
    "brief": "Computes the element-wise floating-point remainder of x/y. The result has the same sign as x. Returns a new list of floats.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 2,
      "element_types": ["numeric", "numeric"],
      "constraints": "Inputs must be numeric and broadcastable. Divisor elements must be non-zero."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float"
    },
    "errors": [
      "TCL_ERROR if any input list is not found or not numeric.",
      "TCL_ERROR if lists are not compatible for the operation (cannot be broadcast).",
      "TCL_ERROR if division by zero is attempted for any element."
    ],
    "example": "set l1 [dl_create 5.0 -5.0 5.0 -5.0 2.7]\nset l2 [dl_create 3.0 3.0 -3.0 -3.0 1.3]\nset res [dl_fmod $l1 $l2]  ;# res is [2.0 -2.0 2.0 -2.0 0.1] (approx for last element)\n\nset res2 [dl_fmod $l1 2.5] ;# res2 is [0.0 -0.0 0.0 -0.0 0.2] (signs from dividend)",
    "see_also": ["dl_mod", "dl_div"]
  },
  {
    "command": "dl_foreach",
    "category": "Control Structure / Iteration",
    "synopsis": "dl_foreach varlist1 dynlist_name1 [varlist2 dynlist_name2 ...] scriptBody",
    "brief": "Iterates over one or more dynamic lists, assigning elements to loop variables. Similar to Tcl's built-in foreach.",
    "inputs": {
      "type": "varied",
      "length": "3+",
      "element_types": ["string (varlist, e.g. x or {x y})", "string (dynlist_name)", "... (more varlist/dynlist_name pairs, optional)", "string (scriptBody)"],
      "constraints": "Each 'varlist' contains one or more Tcl variable names. Each 'dynlist_name' must be an existing dynamic list. 'scriptBody' is a Tcl script."
    },
    "returns": {
      "type": "string",
      "new_object": false,
      "brief": "The result of the last command in 'scriptBody' from the final iteration, or an empty string."
    },
    "side_effects": [
      "Loop variables in 'varlist(s)' are set to elements from the corresponding 'dynlist(s)' for each iteration within 'scriptBody'.",
      "If a dynlist is shorter, its corresponding variables might receive empty strings in later iterations (Tcl standard behavior)."
    ],
    "errors": [
      "TCL_ERROR if any dynlist_name is not found.",
      "TCL_ERROR if varlist structure is invalid or does not match list iteration needs.",
      "TCL_ERROR if scriptBody is syntactically incorrect or an error occurs during its execution."
    ],
    "example": "set names [dl_slist Alice Bob Charles]\nset ages [dl_ilist 30 25 40]\nset cities [dl_slist London Paris Berlin]\n\ndl_foreach name $names age $ages city $cities {\n  puts \"Name: $name, Age: $age, City: $city\"\n}\n# Output:\n# Name: Alice, Age: 30, City: London\n# Name: Bob, Age: 25, City: Paris\n# Name: Charles, Age: 40, City: Berlin\n\nset numbers [dl_create 1 2 3 4 5]\nset sum 0\ndl_foreach n $numbers { incr sum $n }\nputs \"Sum: $sum\" ;# Output: Sum: 15",
    "see_also": ["dl_dotimes", "Tcl built-in foreach", "Tcl built-in for", "Tcl built-in while"]
  },
  {
    "command": "dl_fromto",
    "category": "Creation / Sequence Generation",
    "synopsis": "dl_fromto start end [step]",
    "brief": "Creates a new dynamic list containing a sequence of numbers from 'start' to 'end' with a specified 'step'.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["numeric (start_value)", "numeric (end_value)", "numeric (step_value, optional)"],
      "constraints": "'start', 'end', and 'step' must be numeric. 'step' defaults to 1 if start <= end, or -1 if start > end. 'step' cannot be 0."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "integer or float (depending on input types and step resulting in whole numbers)"
    },
    "errors": [
      "TCL_ERROR if inputs are not numeric.",
      "TCL_ERROR if step is 0.",
      "TCL_ERROR if step direction contradicts start/end relationship (e.g., start < end but step is negative), unless it produces an empty list."
    ],
    "example": "set seq1 [dl_fromto 1 5]         ;# seq1 is [1 2 3 4 5] (integer or float)\nset seq2 [dl_fromto 0 10 2.5]     ;# seq2 is [0.0 2.5 5.0 7.5 10.0]\nset seq3 [dl_fromto 5 1]         ;# seq3 is [5 4 3 2 1]\nset seq4 [dl_fromto 1.0 3.5 0.5]   ;# seq4 is [1.0 1.5 2.0 2.5 3.0 3.5]\nset seq5 [dl_fromto 1 1]         ;# seq5 is [1]",
    "see_also": ["dl_create", "dl_fill", "dl_series", "Tcl built-in for"]
  },
  {
    "command": "dl_gaussian2D",
    "category": "Creation / Image Processing / Kernel Generation",
    "synopsis": "dl_gaussian2D size_x size_y sigma_x sigma_y [theta_rad] [center_x] [center_y] [normalize]",
    "brief": "Generates a 2D Gaussian kernel as a list of float lists.",
    "inputs": {
      "type": "varied",
      "length": "4-8",
      "element_types": [
        "integer (size_x)",
        "integer (size_y)",
        "float (sigma_x)",
        "float (sigma_y)",
        "float (theta_rad, optional)",
        "float (center_x, optional)",
        "float (center_y, optional)",
        "integer_or_boolean (normalize, optional)"
      ],
      "constraints": "size_x, size_y > 0. sigma_x, sigma_y > 0. theta_rad defaults to 0. center_x/y default to middle of kernel. normalize defaults to 1 (true)."
    },
    "returns": {
      "type": "string (name of new 2D DynList)",
      "new_object": true,
      "element_type": "list (of float lists)"
    },
    "errors": [
      "TCL_ERROR if size_x, size_y are not positive integers.",
      "TCL_ERROR if sigma_x, sigma_y are not positive floats.",
      "TCL_ERROR if optional arguments are not valid numbers/booleans.",
      "TCL_ERROR for memory allocation failures."
    ],
    "example": "set kernel1 [dl_gaussian2D 5 5 1.0 1.0] ;# 5x5 kernel, sigma=1.0, normalized\n# kernel1 will be a list of 5 float lists.\n\nset kernel2 [dl_gaussian2D 3 7 0.5 1.5 0.785 0 0 0] ;# 3x7, sigmas 0.5,1.5, rotated PI/4, centered at (0,0) of kernel, not normalized",
    "see_also": ["dl_llist", "dl_flist", "dl_conv", "dl_create"]
  },
  {
    "command": "dl_generateDynList",
    "category": "Creation / Advanced",
    "synopsis": "dl_generateDynList count script_body [type_hint]",
    "brief": "Generates a dynamic list of 'count' elements by repeatedly executing 'script_body'. The script can use an implicit loop variable (e.g., $i) for the current index.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["integer (count)", "string (script_body)", "string (type_hint, optional, e.g., int, float, string)"],
      "constraints": "'count' must be a non-negative integer. 'script_body' is a Tcl script executed 'count' times. It can access a variable (e.g. $dl_generate_idx) for the current 0-based index. The script should return the element for that position."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "any (inferred from script results or based on type_hint)"
    },
    "errors": [
      "TCL_ERROR if 'count' is not a non-negative integer.",
      "TCL_ERROR if 'script_body' is syntactically incorrect or errors during execution.",
      "TCL_ERROR if script results are of inconsistent types and no unambiguous type can be determined, or if they conflict with 'type_hint'."
    ],
    "example": "# Generate a list of squares: 0 1 4 9 16\nset squares [dl_generateDynList 5 {expr {$dl_generate_idx * $dl_generate_idx}} int]\\n\\n# Generate a list of strings: item_0 item_1 item_2\nset items [dl_generateDynList 3 {return \\\"item_$dl_generate_idx\\\"} string]\\n\\n# Generate a list of random floats between 0 and 1\nset randFloats [dl_generateDynList 4 {expr {rand()}} float]",
    "see_also": ["dl_create", "dl_fill", "dl_fromto", "dl_dotimes", "Tcl built-in lgenerate"]
  },
  {
    "command": "dl_get",
    "category": "Accessing Elements",
    "synopsis": "dl_get dynlist_name index1 [index2 ...]",
    "brief": "Retrieves an element or sublist from a dynamic list using one or more 0-based indices. Returns the element value or the name of the sublist.",
    "inputs": {
      "type": "varied",
      "length": "2+",
      "element_types": ["string (dynlist_name)", "integer (index1)", "integer (index2, optional)", "..."],
      "constraints": "'dynlist_name' must be an existing list. Indices must be 0-based integers and within bounds for each list level."
    },
    "returns": {
      "type": "any_or_string (dynlist_name)",
      "new_object": false,
      "brief": "The value of the element at the specified index(es). If the element is a sublist, its name (a string) is returned."
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found.",
      "TCL_ERROR if any index is not an integer or is out of bounds.",
      "TCL_ERROR if too many indices are provided for the list's depth."
    ],
    "example": "set myList [dl_create apple banana cherry]\nset item1 [dl_get $myList 1]       ;# item1 is \"banana\"\n\nset myNums [dl_ilist 10 20 30 40]\nset num_val [dl_get $myNums 0]    ;# num_val is 10\n\nset sub1 [dl_create 1 2]\nset sub2 [dl_slist x y z]\nset lol [dl_llist $sub1 $sub2]\nset sublist_name [dl_get $lol 0]   ;# sublist_name is the name of sub1 (e.g., %listN)\nset deep_item [dl_get $lol 1 2]    ;# deep_item is \"z\" (from sub2 at index 1 of lol, then index 2 of sub2)",
    "see_also": ["dl_first", "dl_last", "dl_index", "dl_put", "dl_set", "dl_sublist"]
  },
  {
    "command": "dl_gt",
    "category": "Logical / Comparison",
    "synopsis": "dl_gt list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise greater than (>) comparison. If more than two arguments, checks chained comparison (e.g., a>b AND b>c). Returns a new list of 0s and 1s.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "Result contains 0 (false) or 1 (true) for each element-wise comparison."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists/values are not compatible for comparison (cannot be broadcast or compared)."
    ],
    "example": "set l1 [dl_create 5 2 8 1 9]\nset l2 [dl_create 3 7 8 0 2]\nset res1 [dl_gt $l1 $l2]   ;# res1 is [1 0 0 1 1]\nset res2 [dl_gt $l1 4]     ;# res2 is [1 0 1 0 1] (l1 compared to scalar 4)\\n\\nset l3 [dl_create 1 1 1]\n# For chained: (l1 > l3) AND (l3 > 0), assuming l3 broadcast against l1, and then scalar 0 against intermediate result\nset res3 [dl_gt $l1 $l3 0] ;# Example: l1[0]=5, l3[0]=1 -> (5>1 AND 1>0) -> 1. l1[1]=2, l3[1]=1 -> (2>1 AND 1>0) -> 1. l1[3]=1, l3[any]=1 -> (1>1 is false) -> 0",
    "see_also": ["dl_lt", "dl_gte", "dl_lte", "dl_eq", "dl_noteq", "dl_gtIndex"]
  },
  {
    "command": "dl_gtIndex",
    "category": "Logical / Comparison / Indexing",
    "synopsis": "dl_gtIndex list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise greater than (>) comparison and returns a new list of 0-based indices where true. For chained comparisons (e.g. a>b AND b>c), indices are where the entire chain is true.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 0-based indices where the comparison is true."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists/values are not compatible for comparison (cannot be broadcast or compared)."
    ],
    "example": "set l1 [dl_create 5 2 8 1 9]\nset l2 [dl_create 3 7 8 0 2]\nset idx1 [dl_gtIndex $l1 $l2] ;# idx1 is [0 3 4]\nset idx2 [dl_gtIndex $l1 4]   ;# idx2 is [0 2 4]\\n\\nset l3 [dl_create 1 1 1]\n# For chained: (l1 > l3) AND (l3 > 0)\nset idx3 [dl_gtIndex $l1 $l3 0] ;# Example: l1[0]=5,l3[0]=1 -> (5>1 AND 1>0) -> true, index 0. l1[1]=2,l3[1]=1 -> (2>1 AND 1>0) -> true, index 1. l1[3]=1,l3[any]=1 -> (1>1 is false) -> false",
    "see_also": ["dl_gt", "dl_ltIndex", "dl_gteIndex", "dl_lteIndex", "dl_eqIndex", "dl_noteqIndex"]
  },
  {
    "command": "dl_gte",
    "category": "Logical / Comparison",
    "synopsis": "dl_gte list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise greater than or equal to (>=) comparison. For chained, e.g., a>=b AND b>=c. Returns list of 0s/1s.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "Result contains 0 (false) or 1 (true) for each element-wise comparison."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists/values are not compatible for comparison (cannot be broadcast or compared)."
    ],
    "example": "set l1 [dl_create 5 2 8 1 9]\nset l2 [dl_create 3 2 8 0 10]\nset res1 [dl_gte $l1 $l2]  ;# res1 is [1 1 1 1 0]\nset res2 [dl_gte $l1 5]    ;# res2 is [1 0 1 0 1]\\n\\nset l3 [dl_create 2 2 2]\n# Chained: (l1 >= l3) AND (l3 >= 2)\nset res3 [dl_gte $l1 $l3 2] ;# e.g. l1[0]=5,l3[0]=2 -> (5>=2 AND 2>=2) -> 1",
    "see_also": ["dl_gt", "dl_lt", "dl_lte", "dl_eq", "dl_noteq", "dl_gteIndex"]
  },
  {
    "command": "dl_gteIndex",
    "category": "Logical / Comparison / Indexing",
    "synopsis": "dl_gteIndex list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise greater than or equal to (>=) comparison and returns a new list of 0-based indices where true. For chained, e.g. a>=b AND b>=c, indices are where entire chain is true.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 0-based indices where the comparison is true."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists/values are not compatible for comparison (cannot be broadcast or compared)."
    ],
    "example": "set l1 [dl_create 5 2 8 1 9]\nset l2 [dl_create 3 2 8 0 10]\nset idx1 [dl_gteIndex $l1 $l2] ;# idx1 is [0 1 2 3]\nset idx2 [dl_gteIndex $l1 5]   ;# idx2 is [0 2 4]\n\nset l3 [dl_create 2 2 2]\n# Chained: (l1 >= l3) AND (l3 >= 2)\nset idx3 [dl_gteIndex $l1 $l3 2] ;# e.g. l1[0]=5,l3[0]=2 -> (5>=2 AND 2>=2) -> true, index 0",
    "example": "set l1 [dl_create 5 2 8 1 9]\nset l2 [dl_create 3 2 8 0 10]\nset idx1 [dl_gteIndex $l1 $l2] ;# idx1 is [0 1 2 3]\nset idx2 [dl_gteIndex $l1 5]   ;# idx2 is [0 2 4]\n\nset l3 [dl_create 2 2 2]
# Chained: (l1 >= l3) AND (l3 >= 2)
set idx3 [dl_gteIndex $l1 $l3 2] ;# e.g. l1[0]=5,l3[0]=2 -> (5>=2 AND 2>=2) -> true, index 0",
    "see_also": ["dl_gte", "dl_gtIndex", "dl_ltIndex", "dl_lteIndex", "dl_eqIndex", "dl_noteqIndex"]
  }
]
