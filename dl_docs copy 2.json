[
  {
    "command": "dl_abs",
    "category": "Arithmetic",
    "synopsis": "dl_abs <list> | dl_abs <number>",
    "brief": "Computes the element-wise absolute value of a list or the absolute value of a single number. Returns a new list containing the result(s).",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as input (or float if input is mixed or float)"
    },
    "errors": [
      "TCL_ERROR: `dl_abs: invalid list operand` if the list is not numeric.",
      "TCL_ERROR if the input list is not found."
    ],
    "example": "dl_tcllist [dl_abs [dl_flist -1.1 1.2]] ;# returns 1.1 1.2\\ndl_tcllist [dl_abs -5.5] ;# returns 5.5",
    "see_also": ["dl_negate", "dl_sign"]
  },
  {
    "command": "dl_acos",
    "category": "Arithmetic / Trigonometric",
    "synopsis": "dl_acos <list> | dl_acos <number>",
    "brief": "Computes the element-wise arc cosine of a list or a single number. Input values must be between -1.0 and 1.0. Values outside this range will return `NaN` (Not a Number). Returns a new list of floats (radians).",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"],
      "constraints": "Elements must be in the range [-1.0, 1.0] to get a valid number. Values outside this range will result in `NaN`."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float",
      "brief": "Values are in radians. An input value outside the valid domain of acos (e.g., > 1.0) will produce a `NaN` element in the output."
    },
    "errors": [
      "TCL_ERROR if the input list is not found or is not numeric."
    ],
    "example": "dl_tcllist [dl_acos [dl_flist 0 0.5 1.1]] ;# returns 1.5708 1.0472 NaN",
    "see_also": ["dl_cos", "dl_asin", "dl_atan"]
  },
  {
    "command": "dl_add",
    "category": "Arithmetic",
    "synopsis": "dl_add <list1> <list2> [<list3>...] | dl_add <list> <number>",
    "brief": "Performs element-wise addition of two or more lists, or a list and a scalar number. Returns a new list.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": "2+",
      "element_types": ["numeric"],
      "constraints": "Inputs must be numeric. All list inputs must have the same length. If one input is a scalar number, it is added to each element of the other list(s)."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Numeric (promoted to float if mixed types)"
    },
    "errors": [
      "TCL_ERROR: `dl_add: unable to combine ...` if lists have different lengths or contain non-numeric data.",
      "TCL_ERROR if an input list is not found."
    ],
    "example": "dl_tcllist [dl_add [dl_ilist 1 2 3] [dl_ilist 10 20 30]] ;# returns 11 22 33\\ndl_tcllist [dl_add [dl_ilist 1 2 3] 5] ;# returns 6 7 8",
    "see_also": ["dl_sub", "dl_mult", "dl_div", "dl_increment"]
  },
  {
    "command": "dl_and",
    "category": "Logical",
    "synopsis": "dl_and <list1> <list2> [<list3>...] | dl_and <list> <number>",
    "brief": "Performs element-wise logical AND on numeric lists. For each element, non-zero numbers are treated as true and zero as false. Returns a new list of 0s and 1s.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": "2+",
      "element_types": ["numeric"],
      "constraints": "Inputs must be numeric. All list inputs must have the same length. If one input is a scalar number, it is evaluated against each element of the other list(s)."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "Result contains 0 (false) or 1 (true)."
    },
    "errors": [
      "TCL_ERROR: `dl_and: operation not supported for strings` if a list is not numeric.",
      "TCL_ERROR: `dl_and: unable to compare ...` if lists have different lengths.",
      "TCL_ERROR if an input list is not found."
    ],
    "example": "dl_tcllist [dl_and [dl_ilist 5 0 -1] [dl_ilist 2 2 0]] ;# returns 1 0 0\\ndl_tcllist [dl_and [dl_ilist 1 0 1 0] 1] ;# returns 1 0 1 0",
    "see_also": ["dl_or", "dl_not", "dl_eq"]
  },
  {
    "command": "dl_andIndex",
    "category": "Logical / Indexing",
    "synopsis": "dl_andIndex <list1> <list2> | dl_andIndex <list> <number>",
    "brief": "Performs element-wise logical AND on two numeric lists and returns a new list containing the indices where the result is true.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 2,
      "element_types": ["numeric"],
      "constraints": "Inputs must be numeric. The two inputs must be two lists of the same length, or one list and one scalar number."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 0-based indices where the logical AND is true."
    },
    "errors": [
      "TCL_ERROR: `dl_andIndex: operation not supported for strings` if a list is not numeric.",
      "TCL_ERROR: `dl_andIndex: unable to compare ...` if lists have different lengths.",
      "TCL_ERROR if an input list is not found."
    ],
    "example": "dl_tcllist [dl_andIndex [dl_ilist 1 0 1 0 1] [dl_ilist 1 1 0 0 1]] ;# returns 0 4\\ndl_tcllist [dl_andIndex [dl_ilist 1 0 1 0] 1] ;# returns 0 2",
    "see_also": ["dl_and", "dl_orIndex", "dl_eqIndex", "dl_select"]
  },
  {
    "command": "dl_append",
    "category": "Manipulation",
    "synopsis": "dl_append <list_name> <value> [<value2> ...]",
    "brief": "Appends one or more values to the end of a list. This command modifies the list in-place.",
    "inputs": {
      "type": "varied",
      "length": "2+",
      "element_types": ["string (list_name)", "any (value_to_append)", "..."]
    },
    "returns": {
      "type": "none",
      "new_object": false,
      "brief": "This command does not return a value."
    },
    "side_effects": [
      "The specified list is modified by appending the new value(s)."
    ],
    "errors": [
      "TCL_ERROR: `expected <type> but got <value>` if a value cannot be converted to the list's datatype.",
      "TCL_ERROR if the list is not found."
    ],
    "example": "set myInts [dl_ilist 1 2];\\ndl_append $myInts 3 4; # myInts is now [1 2 3 4]\\n\\nset myLoL [dl_llist];\\ndl_append $myLoL [dl_ilist 10] [dl_ilist 20]; # myLoL now contains two sub-lists",
    "see_also": ["dl_prepend", "dl_insert", "dl_concat"]
  },
  {
    "command": "dl_asin",
    "category": "Arithmetic / Trigonometric",
    "synopsis": "dl_asin <list> | dl_asin <number>",
    "brief": "Computes the element-wise arc sine of a list or a single number. Input values must be between -1.0 and 1.0. Values outside this range will return `NaN` (Not a Number). Returns a new list of floats (radians).",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"],
      "constraints": "Elements must be in the range [-1.0, 1.0] to get a valid number. Values outside this range will result in `NaN`."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float",
      "brief": "Values are in radians. An input value outside the valid domain of asin (e.g., > 1.0) will produce a `NaN` element in the output."
    },
    "errors": [
      "TCL_ERROR if the input list is not found or is not numeric."
    ],
    "example": "dl_tcllist [dl_asin [dl_flist 0 0.5 -1.1]] ;# returns 0.0 0.5236 NaN",
    "see_also": ["dl_sin", "dl_acos", "dl_atan"]
  },
  {
    "command": "dl_atan",
    "category": "Arithmetic / Trigonometric",
    "synopsis": "dl_atan <list> | dl_atan <number>",
    "brief": "Computes the element-wise arc tangent of a list or a single number. Returns a new list of floats (radians).",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float",
      "brief": "Values are in radians (typically in the range -PI/2 to PI/2)."
    },
    "errors": [
      "TCL_ERROR if the input list is not found or is not numeric."
    ],
    "example": "dl_tcllist [dl_atan [dl_flist 0 1 -1 Inf]] ;# returns 0.0 0.7854 -0.7854 1.5708",
    "see_also": ["dl_tan", "dl_acos", "dl_asin", "dl_atan2"]
  },
  {
    "command": "dl_atan2",
    "category": "Arithmetic / Trigonometric",
    "synopsis": "dl_atan2 y_list x_list | dl_atan2 y_val x_val | dl_atan2 y_list x_val | dl_atan2 y_val x_list",
    "brief": "Computes the element-wise arc tangent of y/x, using the signs of both arguments to determine the quadrant of the result. Returns a new list of floats (radians).",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 2,
      "element_types": ["numeric", "numeric"],
      "constraints": "Inputs must be numeric and broadcastable."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float",
      "brief": "Values are in radians (in the range -PI to PI)."
    },
    "errors": [
      "TCL_ERROR if input lists/values are not found, not numeric, or not compatible."
    ],
    "example": "set y_coords [dl_create 1 -1  1 -1]\nset x_coords [dl_create 1  1 -1 -1]\nset angles_rad [dl_atan2 $y_coords $x_coords] ;# e.g., atan2(1,1) is PI/4\ndl_atan2 0 -1 ;# results in PI",
    "see_also": ["dl_atan", "dl_sin", "dl_cos"]
  },
  {
    "command": "dl_bcycle",
    "category": "Manipulation / List of Lists",
    "synopsis": "dl_bcycle dynlist_name [shift]",
    "brief": "Cycles the elements of the bottom-most sublists of a list of lists (or the elements of a simple list) by a specified 'shift' amount. Positive shift cycles right, negative cycles left. Default shift is 1. Returns a new list.",
    "inputs": {
      "type": "varied",
      "length": "1-2",
      "element_types": ["string (dynlist_name)", "integer (shift_amount)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as input list (preserves structure and element types of sublists)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name not found, or if shift (if provided) is not an integer."
    ],
    "example": "set lol [dl_llist [dl_create 1 2 3] [dl_create a b c d]]\nset cycled1 [dl_bcycle $lol]      ;# shift=1: lol becomes [[3 1 2] [d a b c]]\nset cycled2 [dl_bcycle $lol 2]    ;# shift=2: lol becomes [[2 3 1] [c d a b]]\nset cycled3 [dl_bcycle $lol -1]   ;# shift=-1: lol becomes [[2 3 1] [b c d a]]\n\nset sl [dl_create 10 20 30 40]\nset cycled_sl1 [dl_bcycle $sl]    ;# shift=1: sl becomes [40 10 20 30]\nset cycled_sl2 [dl_bcycle $sl -1] ;# shift=-1: sl becomes [20 30 40 10]",
    "see_also": ["dl_bshift", "dl_cycle", "dl_shift", "dl_subshift"]
  },
  {
    "command": "dl_bins",
    "category": "Utility / Histogramming",
    "synopsis": "dl_bins start stop nbins",
    "brief": "Generates a dynamic list of bin boundaries suitable for creating a histogram. Given a range (start, stop) and a number of bins (nbins), it returns a list of nbins+1 values representing the edges of these bins.",
    "inputs": {
      "type": "varied",
      "length": 3,
      "element_types": ["numeric (start_value)", "numeric (stop_value)", "integer (number_of_bins)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float (or same as start/stop if they are integers and result in integer bins)",
      "brief": "A list of nbins+1 bin edge values."
    },
    "errors": [
      "TCL_ERROR if start/stop are not numeric, nbins is not an integer, or if nbins is non-positive."
    ],
    "example": "set myBinEdges [dl_bins 0 10 5]  ;# myBinEdges might be [0.0 2.0 4.0 6.0 8.0 10.0]\nset anotherSet [dl_bins -1.5 1.5 6] ;# could be [-1.5 -1.0 -0.5 0.0 0.5 1.0 1.5]",
    "see_also": ["dl_hist", "dl_histLists", "dl_cut"]
  },
  {
    "command": "dl_bmax",
    "category": "Reduction / List of Lists",
    "synopsis": "dl_bmax dynlist_name",
    "brief": "Computes the maximum value of each bottom-most sublist in a (potentially nested) dynamic list. Returns a new list with the same structure as the input, but with each bottom-most list replaced by its maximum value.",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["numeric (potentially nested)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as elements of bottom-most input sublists (preserves structure above bottom-most lists)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found, or if any bottom-most list is empty or non-numeric."
    ],
    "example": "set lol [dl_llist [dl_create 1 5 2] [dl_create 10 0 3]]\nset bmax_lol [dl_bmax $lol]   ;# bmax_lol will be a list of lists: [[5] [10]]\n\nset simple_list [dl_create -1 7 3]\nset bmax_simple [dl_bmax $simple_list] ;# bmax_simple will be [7]\n\nset nested [dl_llist [dl_llist [dl_create 1 2] [dl_create 3 8]] [dl_create 4 5]]\nset bmax_nested [dl_bmax $nested] ;# bmax_nested is [[2 8] [5]]",
    "see_also": ["dl_max", "dl_bmin", "dl_bmins", "dl_bmean", "dl_bsums"]
  },
  {
    "command": "dl_bmean",
    "category": "Reduction / List of Lists",
    "synopsis": "dl_bmean dynlist_name",
    "brief": "Computes the mean value of each bottom-most sublist in a (potentially nested) dynamic list. Returns a new list with the same structure as the input, but with each bottom-most list replaced by its mean value (float).",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["numeric (potentially nested)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float (preserves structure above bottom-most lists)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found, or if any bottom-most list is empty or non-numeric."
    ],
    "example": "set lol [dl_llist [dl_create 1 2 3] [dl_create 10 30]]\nset bmean_lol [dl_bmean $lol]   ;# bmean_lol will be a list of lists: [[2.0] [20.0]]\n\nset simple_list [dl_create 1 2 6]\nset bmean_simple [dl_bmean $simple_list] ;# bmean_simple will be [3.0]\n\nset nested [dl_llist [dl_llist [dl_create 1 3] [dl_create 0 10]] [dl_create 4 5]]\nset bmean_nested [dl_bmean $nested] ;# bmean_nested is [[2.0 5.0] [5.0]]",
    "see_also": ["dl_mean", "dl_bmax", "dl_bmin", "dl_bsums", "dl_bstds"]
  },
  {
    "command": "dl_bmin",
    "category": "Reduction / List of Lists",
    "synopsis": "dl_bmin dynlist_name",
    "brief": "Computes the minimum value of each bottom-most sublist in a (potentially nested) dynamic list. Returns a new list with the same structure as the input, but with each bottom-most list replaced by its minimum value.",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["numeric (potentially nested)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as elements of bottom-most input sublists (preserves structure above bottom-most lists)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found, or if any bottom-most list is empty or non-numeric."
    ],
    "example": "set lol [dl_llist [dl_create 1 5 2] [dl_create 10 0 3]]\nset bmin_lol [dl_bmin $lol]   ;# bmin_lol will be a list of lists: [[1] [0]]\n\nset simple_list [dl_create -1 7 3]\nset bmin_simple [dl_bmin $simple_list] ;# bmin_simple will be [-1]\n\nset nested [dl_llist [dl_llist [dl_create 1 2] [dl_create 3 0]] [dl_create -4 5]]\nset bmin_nested [dl_bmin $nested] ;# bmin_nested is [[1 0] [-4]]",
    "see_also": ["dl_min", "dl_bmax", "dl_bmean", "dl_bsums"]
  },
  {
    "command": "dl_bmins",
    "category": "Reduction / List of Lists",
    "synopsis": "dl_bmins dynlist_name",
    "brief": "Alias for `dl_bmin`. Computes the minimum value of each bottom-most sublist.",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["numeric (potentially nested)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as elements of bottom-most input sublists (preserves structure above bottom-most lists)"
    },
    "errors": [
      "See dl_bmin."
    ],
    "example": "# See dl_bmin for examples\nset my_list [dl_llist [dl_create 10 2] [dl_create 5 8]]\nset mins_list [dl_bmins $my_list] ;# mins_list is [[2] [5]]",
    "see_also": ["dl_bmin", "dl_min", "dl_bmaxs", "dl_bmeans", "dl_bsums"]
  },
  {
    "command": "dl_breverse",
    "category": "Manipulation / List of Lists",
    "synopsis": "dl_breverse dynlist_name",
    "brief": "Reverses the elements of each bottom-most sublist in a (potentially nested) dynamic list. If the input is a simple list, it reverses that list. Returns a new list.",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["any (potentially nested)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as input list (preserves structure and element types of sublists)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found."
    ],
    "example": "set lol [dl_llist [dl_create 1 2 3] [dl_slist a b c] [dl_create 10 20]]\nset breversed_lol [dl_breverse $lol]\n# breversed_lol will be {{3 2 1} {c b a} {20 10}}\n\nset simple_list [dl_create 1 2 3 4]\nset breversed_simple [dl_breverse $simple_list]\n# breversed_simple will be {4 3 2 1}",
    "see_also": ["dl_reverse", "dl_reverseAll", "dl_permute"]
  },
  {
    "command": "dl_bshift",
    "category": "Manipulation / List of Lists",
    "synopsis": "dl_bshift dynlist_name [shift]",
    "brief": "Shifts the elements of the bottom-most sublists of a list of lists (or the elements of a simple list) by a specified 'shift' amount. Positive shift moves elements right (filling with 0/empty string), negative shifts left. Default shift is 1. Elements shifted off ends are lost. Returns a new list.",
    "inputs": {
      "type": "varied",
      "length": "1-2",
      "element_types": ["string (dynlist_name)", "integer (shift_amount)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as input list (preserves structure and element types of sublists)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name not found or if shift amount is invalid."
    ],
    "example": "set lol [dl_llist [dl_create 1 2 3] [dl_slist a b c]]\nset bshifted_right [dl_bshift $lol 1]\n# bshifted_right is {{0 1 2} {\"\" a b}}\nset bshifted_left [dl_bshift $lol -1]\n# bshifted_left is {{2 3 0} {b c \"\"}}\n\nset simple [dl_create 1 2 3 4]\nset shifted_simple [dl_bshift $simple 2]\n# shifted_simple is {0 0 1 2}",
    "see_also": ["dl_bcycle", "dl_shift", "dl_cycle", "dl_subshift"]
  },
  {
    "command": "dl_bsort",
    "category": "Manipulation / List of Lists / Sorting",
    "synopsis": "dl_bsort dynlist_name",
    "brief": "Sorts the elements of each bottom-most sublist in a (potentially nested) dynamic list in ascending order. If the input is a simple list, it sorts that list. Returns a new list.",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["any (potentially nested, sortable elements within bottom-most lists)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as input list (preserves structure and element types of sublists)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found or if elements within a sublist are not mutually sortable (e.g., mixing strings and numbers in a way that Tcl can't compare)."
    ],
    "example": "set lol [dl_llist [dl_create 3 1 2] [dl_slist c a b] [dl_create 20 5 10]]\nset bsorted_lol [dl_bsort $lol]\n# bsorted_lol will be {{1 2 3} {a b c} {5 10 20}}\n\nset simple_list [dl_create 3 1 4 2]\nset bsorted_simple [dl_bsort $simple_list]\n# bsorted_simple will be {1 2 3 4}",
    "see_also": ["dl_sort", "dl_bsortIndices", "dl_sortIndices", "dl_sortByList"]
  },
  {
    "command": "dl_bsortIndices",
    "category": "Manipulation / List of Lists / Sorting / Indexing",
    "synopsis": "dl_bsortIndices dynlist_name",
    "brief": "Sorts each bottom-most sublist in a (potentially nested) dynamic list and returns a new list containing the 0-based indices that would sort each original sublist. If the input is a simple list, it returns the sort indices for that list.",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["any (potentially nested, sortable elements within bottom-most lists)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer (preserves structure above bottom-most lists, bottom-most lists contain indices)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found or if elements within a sublist are not mutually sortable."
    ],
    "example": "set lol [dl_llist [dl_create 30 10 20] [dl_slist c a b]]\nset bsorted_indices_lol [dl_bsortIndices $lol]\n# bsorted_indices_lol will be {{1 2 0} {1 2 0}} (indices to sort each sublist)\n\nset simple_list [dl_create 30 10 40 20]\nset bsorted_indices_simple [dl_bsortIndices $simple_list]\n# bsorted_indices_simple will be {1 3 0 2}",
    "see_also": ["dl_bsort", "dl_sortIndices", "dl_sort", "dl_permute"]
  },
  {
    "command": "dl_bstds",
    "category": "Reduction / List of Lists / Statistics",
    "synopsis": "dl_bstds dynlist_name",
    "brief": "Computes the standard deviation of each bottom-most sublist in a (potentially nested) dynamic list. Returns a new list with the same structure as the input, but with each bottom-most list replaced by its standard deviation value (float).",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["numeric (potentially nested)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float (preserves structure above bottom-most lists)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found, or if any bottom-most list is empty, non-numeric, or has insufficient elements for std dev calculation (e.g., fewer than 2 elements for sample std dev)."
    ],
    "example": "set lol [dl_llist [dl_create 1 2 3] [dl_create 10 20 30 40]]\nset bstds_lol [dl_bstds $lol]   ;# bstds_lol might be e.g. [[1.0] [12.91]] (actual values depend on sample vs population std dev)\n\nset simple_list [dl_create 1 1 1 1]\nset bstds_simple [dl_bstds $simple_list] ;# bstds_simple will be [0.0]\n\nset nested [dl_llist [dl_llist [dl_create 1 3] [dl_create 0 10 5]] [dl_create 4 5 6]]\nset bstds_nested [dl_bstds $nested] ;# e.g. [[1.414] [5.0] [1.0]]",
    "see_also": ["dl_std", "dl_bmean", "dl_bvar", "dl_hstd", "dl_hvar"]
  },
  {
    "command": "dl_bsums",
    "category": "Reduction / List of Lists",
    "synopsis": "dl_bsums dynlist_name",
    "brief": "Computes the sum of each bottom-most sublist in a (potentially nested) dynamic list. Returns a new list with the same structure as the input, but with each bottom-most list replaced by its sum.",
    "inputs": {
      "type": "DynList",
      "length": 1,
      "element_types": ["numeric (potentially nested)"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Numeric (same as elements of bottom-most input sublists if uniform, else promoted, e.g., to float. Preserves structure above bottom-most lists)."
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found, or if any bottom-most list is empty or contains non-numeric elements that cannot be summed."
    ],
    "example": "set lol [dl_llist [dl_create 1 2 3] [dl_create 10 20.5]]\nset bsums_lol [dl_bsums $lol]   ;# bsums_lol will be a list of lists: [[6] [30.5]]\n\nset simple_list [dl_create -1 7 3 0.5]\nset bsums_simple [dl_bsums $simple_list] ;# bsums_simple will be [9.5]\n\nset nested [dl_llist [dl_llist [dl_create 1 2] [dl_create 3 4]] [dl_create 5 6]]\nset bsums_nested [dl_bsums $nested] ;# bsums_nested is [[3 7] [11]]",
    "see_also": ["dl_sum", "dl_bmean", "dl_bmin", "dl_bmax", "dl_prod"]
  },
  {
    "command": "dl_ceil",
    "category": "Arithmetic",
    "synopsis": "dl_ceil dynlist_name | dl_ceil number",
    "brief": "Computes the element-wise ceiling of a dynamic list or number (smallest integer not less than each value). Returns a new list.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer (or float representing an integer, e.g. 2.0)"
    },
    "errors": [
      "TCL_ERROR if input is not a valid dynlist or number, or if the list is a string list, or for general math errors."
    ],
    "example": "set myList [dl_create 1.2 2.0 -3.7 4]]\nset ceilList [dl_ceil $myList] ;# ceilList will be [2.0 2.0 -3.0 4.0] (or integer equivalents)\ndl_ceil -5.5 ;# returns a new list containing [-5.0]",
    "see_also": ["dl_floor", "dl_round", "dl_int"]
  },
  {
    "command": "dl_choose",
    "category": "Manipulation / Selection",
    "synopsis": "dl_choose source_dynlist_name index_dynlist_name",
    "brief": "Selects elements from 'source_dynlist' based on 0-based indices provided in 'index_dynlist'. Returns a new list containing the chosen elements in the order specified by 'index_dynlist'. Allows for repeated selection of elements.",
    "inputs": {
      "type": "varied",
      "length": 2,
      "element_types": ["string (source_dynlist_name)", "string (index_dynlist_name)"]
    },
    "source_dynlist_constraints": {
        "type": "DynList",
        "element_types": ["any"],
        "brief": "The dynamic list from which elements are chosen."
    },
    "index_dynlist_constraints": {
        "type": "DynList",
        "element_types": ["integer (or numeric coercible to integer)"],
        "brief": "A dynamic list of 0-based indices specifying which elements to choose from 'source_dynlist'. Indices must be within the valid range [0, length(source_dynlist)-1]."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "any (same as elements of source_dynlist)"
    },
    "errors": [
      "TCL_ERROR if 'source_dynlist_name' or 'index_dynlist_name' are not found.",
      "TCL_ERROR if 'index_dynlist' contains non-integer values or out-of-bounds indices.",
      "TCL_ERROR if the wrong number of arguments is provided (expects 2 list names)."
    ],
    "example": "set sourceList [dl_create apple banana cherry date elderberry]\nset indexList [dl_create 0 3 1 3 0]\nset chosenList [dl_choose $sourceList $indexList] ;# chosenList will be a new dynlist containing [apple date banana date apple]",
    "see_also": ["dl_select", "dl_get", "dl_permute", "dl_pickone"]
  },
  {
    "command": "dl_clean",
    "category": "Memory Management",
    "synopsis": "dl_clean",
    "brief": "Deletes all temporary dynamic lists in the current interpreter. Temporary lists are those whose names start with a '%' (e.g., %list0, %list123). Also resets the internal counter for temporary list names.",
    "inputs": {
      "type": "none",
      "length": 0
    },
    "returns": {
      "type": "void (TCL_OK on success)",
      "new_object": false
    },
    "side_effects": [
      "All temporary dynamic lists (names starting with '%') are deleted.",
      "The internal counter for generating temporary list names is reset to 0."
    ],
    "errors": [
      "TCL_ERROR if internal interpreter data (DLSHINFO) cannot be accessed (very unlikely)."
    ],
    "example": "dl_create 1 2 3 ;# Might create a temporary list like %list0\nset x [dl_add [dl_create 10] [dl_create 20]] ;# x will be name of a new temp list like %list1\ndl_clean ;# Deletes %list0, %list1 (if they were indeed temp names) and any other such lists.",
    "see_also": ["dl_delete", "dl_cleanReturns", "dg_clean"]
  },
  {
    "command": "dl_cleanReturns",
    "category": "Memory Management",
    "synopsis": "dl_cleanReturns",
    "brief": "Deletes all 'return' dynamic lists in the current interpreter. Return lists are typically those created by 'dl_return' and have names starting with a '>' (e.g., >0<). Also resets the internal counter for return list names.",
    "inputs": {
      "type": "none",
      "length": 0
    },
    "returns": {
      "type": "void (TCL_OK on success)",
      "new_object": false
    },
    "side_effects": [
      "All 'return' dynamic lists (names starting with '>') are deleted.",
      "The internal counter for generating return list names is reset to 0."
    ],
    "errors": [
      "TCL_ERROR if internal interpreter data (DLSHINFO) cannot be accessed (very unlikely)."
    ],
    "example": "proc my_proc {val} {\n  set temp_list [dl_create $val $val*2]\n  return [dl_return $temp_list]\n}\nset ret_list_name [my_proc 5] ;# ret_list_name might be '>0<'\ndl_cleanReturns ;# Deletes the list named by ret_list_name (e.g., >0<) and any other such lists.",
    "see_also": ["dl_delete", "dl_clean", "dl_return"]
  },
  {
    "command": "dl_clist",
    "category": "Creation",
    "synopsis": "dl_clist [value1 value2 ... | {value_list} | dynlist_name1 dynlist_name2 ...]",
    "brief": "Creates a new dynamic list of type character (byte). Initializes with optional values, which can be individual numeric character codes, a Tcl list of codes, or elements from other dynlists (converted to char).",
    "inputs": {
      "type": "varied (values, Tcl list, or dynlist names)",
      "length": "0+",
      "element_types": ["integer (character code)", "Tcl list of integer character codes", "string (dynlist_name)"],
      "constraints": "Numeric values are treated as character codes (e.g., 65 for 'A'). Elements from other dynlists are converted to char if possible (numeric types truncated, strings likely take first char or error, lists of lists likely error)."
    },
    "returns": {
      "type": "string (name of new char DynList)",
      "new_object": true,
      "element_type": "char (byte)"
    },
    "errors": [
      "TCL_ERROR if non-numeric values are provided that cannot be converted to char codes.",
      "TCL_ERROR if a named dynlist argument is not found.",
      "TCL_ERROR if conversion from elements of a source dynlist to char is not possible."
    ],
    "example": "set charList1 [dl_clist 65 66 67]       ;# charList1 contains 'A', 'B', 'C' (byte values)\nset charList2 [dl_clist {72 101 108 108 111}] ;# charList2 contains 'H', 'e', 'l', 'l', 'o'\nset numList [dl_create 97 98.5]\nset charList3 [dl_clist $numList 33]    ;# charList3 contains 'a', 'b', '!' (98.5 truncated to 98)",
    "see_also": ["dl_create", "dl_ilist", "dl_flist", "dl_slist", "dl_llist", "dl_char"]
  },
  {
    "command": "dl_collapse",
    "category": "Manipulation / Restructuring",
    "synopsis": "dl_collapse list_of_lists_name",
    "brief": "Collapses a list of lists by one level, concatenating all sublists into a new single list. The data type of the new list is determined by the elements in the sublists.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["The name of a dynamic list which must be a list of lists (type DF_LIST). Each sublist contains the elements to be concatenated."]
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "any (determined by common type of elements in sublists; may be promoted, e.g., int + float -> float)"
    },
    "errors": [
      "TCL_ERROR if the input is not a valid dynlist name or the list is not found.",
      "TCL_ERROR if the input dynlist is not a list of lists (DF_LIST type).",
      "TCL_ERROR if memory allocation fails."
    ],
    "example": "set lol [dl_llist [dl_create 1 2] [dl_create 3 4 5] [dl_create 6]]\nset flatList [dl_collapse $lol] ;# flatList will be a new dynlist containing [1 2 3 4 5 6]\n\nset mix [dl_llist [dl_ilist 10 20] [dl_flist 30.3 40.4]]\nset flatMix [dl_collapse $mix] ;# flatMix will be a new float dynlist [10.0 20.0 30.3 40.4]",
    "see_also": ["dl_unpack", "dl_deepUnpack", "dl_concat", "dl_pack", "dl_llist"]
  },
  {
    "command": "dl_combine",
    "category": "Creation / Concatenation",
    "synopsis": "dl_combine dynlist1_name dynlist2_name [dynlist3_name ...]",
    "brief": "Creates a new dynamic list by concatenating two or more existing dynamic lists. All input lists must be of the same data type.",
    "inputs": {
      "type": "strings (dynlist_names)",
      "length": "2+",
      "element_types": ["string (name of a dynlist)"],
      "constraints": "All specified dynamic lists must exist and have the same underlying data type (e.g., all DF_LONG, all DF_FLOAT, etc.)."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "Same as the input dynlists."
    },
    "errors": [
      "TCL_ERROR if fewer than two dynlist names are provided.",
      "TCL_ERROR if any dynlist name is not found.",
      "TCL_ERROR if input lists are not of the same data type.",
      "TCL_ERROR if memory allocation for the new list fails."
    ],
    "example": "set listA [dl_create 1 2 3]\nset listB [dl_flist 4.0 5.0]\nset listC [dl_create 6 7]\n# dl_combine $listA $listB ;# This would error as listA (int) and listB (float) are different types\nset combinedList [dl_combine $listA $listC] ;# combinedList will be a new int dynlist [1 2 3 6 7]",
    "see_also": ["dl_concat", "dl_interleave", "dl_append", "dl_create"]
  },
  {
    "command": "dl_concat",
    "category": "Manipulation / Concatenation",
    "synopsis": "dl_concat dest_dynlist_name source_dynlist_name [source_dynlist_name2 ...]",
    "brief": "Concatenates one or more source dynamic lists onto a destination dynamic list. The destination list is modified in-place. All lists must be of the same data type.",
    "inputs": {
      "type": "strings (dynlist_names)",
      "length": "2+",
      "element_types": ["string (name of destination dynlist)", "string (name of source dynlist)"],
      "constraints": "All specified dynamic lists must exist and have the same underlying data type. The first list is the destination and will be modified."
    },
    "returns": {
      "type": "string (name of modified destination DynList)",
      "new_object": false
    },
    "side_effects": [
      "The 'dest_dynlist_name' is modified by appending elements from all 'source_dynlist_name(s)'."
    ],
    "errors": [
      "TCL_ERROR if fewer than two dynlist names are provided.",
      "TCL_ERROR if any dynlist name is not found.",
      "TCL_ERROR if source lists are not of the same data type as the destination list.",
      "TCL_ERROR if memory (re)allocation for the destination list fails during concatenation."
    ],
    "example": "set list1 [dl_create 1 2]\nset list2 [dl_create 3 4]\nset list3 [dl_create 5 6]\ndl_concat $list1 $list2 $list3 ;# list1 is now [1 2 3 4 5 6]\n# dl_concat $list1 [dl_flist 7.0 8.0] ;# This would error if list1 is an int list.",
    "see_also": ["dl_combine", "dl_append", "dl_interleave"]
  },
  {
    "command": "dl_conv",
    "category": "Arithmetic / Signal Processing",
    "synopsis": "dl_conv data_dynlist_name kernel_dynlist_name [mode]",
    "brief": "Performs 1D convolution of a data dynamic list with a kernel dynamic list. Returns a new list containing the result.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["string (data_dynlist_name)", "string (kernel_dynlist_name)", "string (mode, optional)"],
      "constraints": "'data_dynlist_name' and 'kernel_dynlist_name' must refer to 1D numeric dynamic lists. 'mode', if provided, is a string, typically one of 'full', 'same', or 'valid'. Defaults to 'full' if omitted. Kernel list must not be empty."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "float"
    },
    "errors": [
      "TCL_ERROR if input lists are not found, are not numeric, or are not 1D.",
      "TCL_ERROR if the kernel list is empty.",
      "TCL_ERROR if an invalid 'mode' string is provided.",
      "TCL_ERROR for memory allocation failures."
    ],
    "example": "set data [dl_ilist 1 2 3 4 5]\nset kernel [dl_ilist 1 0 -1]\nset res_full [dl_conv $data $kernel]          ;# Result: [1.0 2.0 2.0 2.0 2.0 -4.0 -5.0] (length 7)\nset res_same [dl_conv $data $kernel same]    ;# Result: [2.0 2.0 2.0 2.0 -4.0] (length 5)\nset res_valid [dl_conv $data $kernel valid]   ;# Result: [2.0 2.0 2.0] (length 3)",
    "see_also": ["dl_conv2", "dl_add", "dl_mult", "dl_diff"]
  },
  {
    "command": "dl_conv2",
    "category": "Arithmetic / Signal Processing / Filtering",
    "synopsis": "dl_conv2 data_dynlist_name b_coeffs_dynlist_name a_coeffs_dynlist_name",
    "brief": "Performs a 1D recursive (IIR-like) convolution/filter operation on a data dynamic list using feedforward (b) and feedback (a) coefficients. Returns a new list.",
    "inputs": {
      "type": "strings (dynlist_names)",
      "length": 3,
      "element_types": ["string (data_dynlist_name)", "string (b_coeffs_dynlist_name)", "string (a_coeffs_dynlist_name)"],
      "constraints": "All lists must be 1D numeric dynamic lists. The first element of 'a_coeffs_dynlist_name' (a[0]) should ideally be 1 or non-zero for stability; if not 1, it might be used for normalization. Coefficient lists cannot be empty."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "float"
    },
    "errors": [
      "TCL_ERROR if input lists are not found, are not numeric, or are not 1D.",
      "TCL_ERROR if coefficient lists (b or a) are empty.",
      "TCL_ERROR if a[0] coefficient is zero and not handled by internal normalization, potentially leading to division by zero.",
      "TCL_ERROR for memory allocation failures or other numerical issues during filtering."
    ],
    "example": "set signal [dl_ilist 1 0 0 0 0]\nset b_coeffs [dl_flist 1.0]       ;# FIR filter: y[n] = x[n] + 0.5*x[n-1]\nset a_coeffs [dl_flist 1.0 -0.5]  ;# IIR filter: y[n] = x[n] + 0.5*y[n-1]\n# Example for a simple IIR filter (e.g. y[n] = x[n] + 0.8*y[n-1]):\nset b_iir [dl_flist 1.0]\nset a_iir [dl_flist 1.0 -0.8]\nset filtered_signal [dl_conv2 $signal $b_iir $a_iir]\n# filtered_signal could be [1.0 0.8 0.64 0.512 0.4096]",
    "see_also": ["dl_conv", "dl_diff"]
  },
  {
    "command": "dl_cos",
    "category": "Arithmetic / Trigonometric",
    "synopsis": "dl_cos dynlist_name | dl_cos number_radians",
    "brief": "Computes the element-wise cosine of a dynamic list or a single number. Input values are assumed to be in radians. Returns a new list of floats.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"],
      "constraints": "Input elements are interpreted as angles in radians."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float",
      "brief": "Resulting values are in the range [-1.0, 1.0]."
    },
    "errors": [
      "TCL_ERROR if input list is not found or is a string list.",
      "TCL_ERROR for general math errors during cosine calculation."
    ],
    "example": "set angles_rad [dl_create 0 1.5708 3.14159 6.28318] ;# 0, PI/2, PI, 2*PI\nset cos_values [dl_cos $angles_rad] ;# cos_values will be approximately [1.0 0.0 -1.0 1.0]\ndl_cos 0.7854 ;# cos(PI/4) approx 0.707",
    "see_also": ["dl_sin", "dl_tan", "dl_acos", "dl_cosh"]
  },
  {
    "command": "dl_cosh",
    "category": "Arithmetic / Hyperbolic",
    "synopsis": "dl_cosh dynlist_name | dl_cosh number",
    "brief": "Computes the element-wise hyperbolic cosine of a dynamic list or a single number. Returns a new list of floats.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float",
      "brief": "Resulting values are always >= 1.0."
    },
    "errors": [
      "TCL_ERROR if input list is not found or is a string list.",
      "TCL_ERROR for general math errors (e.g., overflow for large magnitude inputs)."
    ],
    "example": "set values [dl_create 0 1 -1 2.5]\nset cosh_values [dl_cosh $values] ;# cosh_values approx [1.0 1.543 1.543 6.132]\ndl_cosh 0 ;# Result is 1.0",
    "see_also": ["dl_sinh", "dl_tanh", "dl_cos"]
  },
  {
    "command": "dl_countOccurences",
    "category": "Searching / Counting",
    "synopsis": "dl_countOccurences source_dynlist_name search_item_name_or_value",
    "brief": "Counts the number of non-overlapping occurrences of a search item (which can be a dynlist or a literal value) within a source dynlist.",
    "inputs": {
      "type": "varied",
      "length": 2,
      "element_types": ["string (source_dynlist_name)", "string_or_value (search_item_name_or_value)"],
      "constraints": "The 'source_dynlist' can be of any type. The 'search_item' will be compared element-wise if it's a list, or as a single value. If 'search_item' is a list, its elements must be comparable to the elements of 'source_dynlist'."
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "The total number of non-overlapping times the search_item is found in source_dynlist."
    },
    "errors": [
      "TCL_ERROR if source_dynlist_name or search_item_name (if provided as a list name) is not found.",
      "TCL_ERROR if types are incompatible for comparison.",
      "TCL_ERROR if the wrong number of arguments is provided (expects 2)."
    ],
    "example": "set mainList [dl_create 1 2 3 1 2 4 1 2 3 5]\nset subList [dl_create 1 2]\nset count1 [dl_countOccurences $mainList $subList]   ;# count1 will be 3\nset count2 [dl_countOccurences $mainList 3]          ;# count2 will be 2\n\nset strList [dl_slist apple banana apple orange apple]\nset count3 [dl_countOccurences $strList apple]     ;# count3 will be 3",
    "see_also": ["dl_find", "dl_findAll", "dl_findIndices", "dl_findPatterns"]
  },
  {
    "command": "dl_create",
    "category": "Creation",
    "synopsis": "dl_create [value1 value2 ... | {value_list} | dynlist_name1 dynlist_name2 ...]",
    "brief": "Creates a new dynamic list. The type of the list is inferred from the first value provided, or it may default if no values are given. Initializes with optional values.",
    "inputs": {
      "type": "varied (values, Tcl list, or dynlist names)",
      "length": "0+",
      "element_types": ["any (literal values)", "Tcl list of values", "string (dynlist_name)"],
      "constraints": "If multiple values or lists are provided, they should be compatible for forming a single typed list (e.g., all numbers, all strings, or types that can be promoted). If dynlist names are given, their elements are copied."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "any (inferred from input: integer, float, string, list, etc.)"
    },
    "errors": [
      "TCL_ERROR if provided values cannot be consistently typed or converted.",
      "TCL_ERROR if a named dynlist argument is not found or its elements are incompatible.",
      "TCL_ERROR if memory allocation fails."
    ],
    "example": "set list1 [dl_create]                   ;# Creates an empty list (type might be initially flexible or default)\nset list2 [dl_create 1 2 3]             ;# Creates an integer list: [1 2 3]\nset list3 [dl_create 1.0 2 3.5]         ;# Creates a float list: [1.0 2.0 3.5]\nset list4 [dl_create hello world]         ;# Creates a string list: [hello world]\nset list5 [dl_create {a b c}]           ;# Creates a string list: [a b c] (from Tcl list)\nset list6 [dl_create $list2 $list3]     ;# Creates a new list by copying elements from list2 then list3 (likely becomes float list)",
    "see_also": ["dl_ilist", "dl_flist", "dl_slist", "dl_llist", "dl_clist", "dl_append", "dl_delete"]
  },
  {
    "command": "dl_cumprod",
    "category": "Arithmetic / Accumulation",
    "synopsis": "dl_cumprod dynlist_name",
    "brief": "Computes the cumulative product of elements in a numeric dynamic list. Returns a new list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["numeric"],
      "constraints": "Input list must be numeric and 1D. Behavior for empty list might be an error or an empty list."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "numeric (promoted as necessary, e.g., to float to accommodate large products or float inputs)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found or is not a numeric list.",
      "TCL_ERROR if the list is empty (potentially).",
      "TCL_ERROR for numeric overflow if products become too large for the data type and are not handled by promotion to float."
    ],
    "example": "set myList [dl_create 1 2 3 4 0.5]\nset cProd [dl_cumprod $myList] ;# cProd will be [1.0 2.0 6.0 24.0 12.0]\n\nset another [dl_ilist 2 3 -1 5]\nset cProd2 [dl_cumprod $another] ;# cProd2 could be [2 6 -6 -30] (as integers or floats)",
    "see_also": ["dl_cumsum", "dl_prod", "dl_sum"]
  },
  {
    "command": "dl_cumsum",
    "category": "Arithmetic / Accumulation",
    "synopsis": "dl_cumsum dynlist_name",
    "brief": "Computes the cumulative sum of elements in a numeric dynamic list. Returns a new list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["numeric"],
      "constraints": "Input list must be numeric and 1D. Behavior for empty list might be an error or an empty list."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "numeric (promoted as necessary, e.g., to float to accommodate large sums or float inputs)"
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found or is not a numeric list.",
      "TCL_ERROR if the list is empty (potentially).",
      "TCL_ERROR for numeric overflow if sums become too large for the data type and are not handled by promotion to float."
    ],
    "example": "set myList [dl_create 1 2 3 4 -5.5]\nset cSum [dl_cumsum $myList] ;# cSum will be [1.0 3.0 6.0 10.0 4.5]\n\nset another [dl_ilist 10 20 -5 15]\nset cSum2 [dl_cumsum $another] ;# cSum2 could be [10 30 25 40] (as integers or floats)",
    "see_also": ["dl_cumprod", "dl_sum", "dl_prod"]
  },
  {
    "command": "dl_cycle",
    "category": "Manipulation / Permutation",
    "synopsis": "dl_cycle dynlist_name [shift_amount]",
    "brief": "Cycles the elements of a 1D dynamic list by a specified 'shift_amount'. Positive shifts right, negative shifts left. Elements wrap around. Default shift is 1. Returns a new list.",
    "inputs": {
      "type": "varied",
      "length": "1-2",
      "element_types": ["string (dynlist_name)", "integer (shift_amount, optional)"],
      "constraints": "Input list must be 1D. If 'shift_amount' is not provided, it defaults to 1."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "Same as input dynlist."
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found.",
      "TCL_ERROR if 'shift_amount' (if provided) is not an integer.",
      "TCL_ERROR if input list is not 1D (e.g. a list of lists)."
    ],
    "example": "set myList [dl_create a b c d e]\nset cycled1 [dl_cycle $myList]        ;# cycled1 is [e a b c d] (default shift 1)\nset cycled2 [dl_cycle $myList 2]      ;# cycled2 is [d e a b c]\nset cycled3 [dl_cycle $myList -1]     ;# cycled3 is [b c d e a]",
    "see_also": ["dl_shift", "dl_bcycle", "dl_bshift", "dl_permute", "dl_reverse"]
  },
  {
    "command": "dl_datatype",
    "category": "Introspection",
    "synopsis": "dl_datatype dynlist_name",
    "brief": "Returns a string representing the underlying data type of the specified dynamic list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["The name of an existing dynamic list."]
    },
    "returns": {
      "type": "string",
      "new_object": false,
      "brief": "A string identifier for the data type (e.g., \"DF_LONG\", \"DF_FLOAT\", \"DF_STRING\", \"DF_LIST\", \"DF_CHAR\")."
    },
    "errors": [
      "TCL_ERROR if dynlist_name does not refer to an existing dynamic list."
    ],
    "example": "set intList [dl_ilist 1 2 3]\nset type1 [dl_datatype $intList]    ;# type1 will be \"DF_LONG\" (or similar for integer)\n\nset floatList [dl_flist 1.0 2.5]\nset type2 [dl_datatype $floatList]  ;# type2 will be \"DF_FLOAT\" (or DF_DOUBLE)\n\nset stringList [dl_slist hello world]\nset type3 [dl_datatype $stringList] ;# type3 will be \"DF_STRING\"",
    "see_also": ["dl_exists", "dl_length", "dl_llength", "dl_depth", "dl_isMatrix"]
  },
  {
    "command": "dl_deep_pack",
    "category": "Serialization / Restructuring",
    "synopsis": "dl_deep_pack list_of_lists_name",
    "brief": "Serializes a potentially nested list of lists into a flat binary dynamic list. This is useful for efficient storage or transmission and can be reversed using dl_deep_unpack.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["The name of an existing dynamic list, typically of type DF_LIST, containing potentially nested sublists."]
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "DF_BINARY (or DF_CHAR, containing a compact binary representation)",
      "brief": "The packed list contains information about the original structure and all its elements."
    },
    "errors": [
      "TCL_ERROR if list_of_lists_name is not found.",
      "TCL_ERROR if the input list is not a list of lists (DF_LIST) or cannot be packed for other reasons (e.g. unsupported element types for packing within sublists if very heterogeneous).",
      "TCL_ERROR for memory allocation failures during the packing process."
    ],
    "example": "set lol [dl_llist [dl_ilist 1 2] [dl_llist [dl_flist 3.0 4.0] [dl_slist foo]] [dl_ilist 5]]\nset packed_lol [dl_deep_pack $lol]\n# packed_lol is now a binary dynlist containing the serialized form of lol\n\n# To restore:\n# set restored_lol [dl_deep_unpack $packed_lol]",
    "see_also": ["dl_deep_unpack", "dl_pack", "dl_unpack", "dl_toString", "dl_fromString"]
  },
  {
    "command": "dl_deep_unpack",
    "category": "Serialization / Restructuring",
    "synopsis": "dl_deep_unpack packed_dynlist_name",
    "brief": "Reconstructs a potentially nested list of lists from a flat binary dynamic list that was created by dl_deep_pack.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["The name of an existing dynamic list of type DF_BINARY (or DF_CHAR) containing data previously serialized by dl_deep_pack."]
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "DF_LIST (reconstructing the original nested structure and element types)",
      "brief": "The new list is a deep copy of the original structure that was packed."
    },
    "errors": [
      "TCL_ERROR if packed_dynlist_name is not found.",
      "TCL_ERROR if the input list is not of type DF_BINARY/DF_CHAR or if its content is not a valid packed representation (e.g., corrupted data, incorrect format).",
      "TCL_ERROR for memory allocation failures during unpacking."
    ],
    "example": "# Assume packed_lol was created by: set packed_lol [dl_deep_pack $some_list_of_lists]\nset unpacked_lol [dl_deep_unpack $packed_lol]\n# unpacked_lol is now a new list of lists, identical in structure and content to $some_list_of_lists",
    "see_also": ["dl_deep_pack", "dl_unpack", "dl_pack", "dl_fromString", "dl_toString"]
  },
  {
    "command": "dl_delete",
    "category": "Memory Management",
    "synopsis": "dl_delete dynlist_name1 [dynlist_name2 ...]",
    "brief": "Deletes one or more specified dynamic lists from memory.",
    "inputs": {
      "type": "strings (dynlist_names)",
      "length": "1+",
      "element_types": ["string (name of an existing dynamic list)"],
      "constraints": "At least one dynlist name must be provided."
    },
    "returns": {
      "type": "void (TCL_OK on success)",
      "new_object": false
    },
    "side_effects": [
      "The specified dynamic lists are deallocated and their names are removed from the interpreter's list registry."
    ],
    "errors": [
      "TCL_ERROR if no dynlist names are provided.",
      "TCL_ERROR if any specified dynlist_name is not found (unless a -nocomplain option is supported and used, which is not assumed here)."
    ],
    "example": "set myList1 [dl_create 1 2 3]\nset myList2 [dl_slist a b c]\ndl_delete $myList1 $myList2 ;# Both myList1 and myList2 are deleted\n# dl_exists $myList1 ;# would return 0",
    "see_also": ["dl_clean", "dl_cleanReturns", "dg_delete", "dl_reset"]
  },
  {
    "command": "dl_deleteTrace",
    "category": "Introspection / Tracing",
    "synopsis": "dl_deleteTrace dynlist_name trace_id",
    "brief": "Removes a previously set trace from a dynamic list. The trace_id is typically returned by the command that set the trace.",
    "inputs": {
      "type": "varied",
      "length": 2,
      "element_types": ["string (dynlist_name)", "string_or_integer (trace_id)"],
      "constraints": "'dynlist_name' must refer to an existing dynamic list that has an active trace matching 'trace_id'."
    },
    "returns": {
      "type": "void (TCL_OK on success)",
      "new_object": false
    },
    "side_effects": [
      "The specified trace is removed from the dynamic list. The associated Tcl script/command will no longer execute when traced operations occur."
    ],
    "errors": [
      "TCL_ERROR if dynlist_name is not found.",
      "TCL_ERROR if trace_id is invalid, not found for the given list, or does not correspond to an active trace.",
      "TCL_ERROR if the dynamic list is not a traced variable or if there are internal issues with trace management."
    ],
    "example": "# Assuming 'myList' has a trace with id 'trace123' (e.g., set by a hypothetical 'dl_addTrace')\n# proc my_trace_proc {args} { puts \"Trace fired: $args\" }\n# set tr_id [dl_addTrace myList {write read} my_trace_proc] ;# hypothetical\n# dl_append myList 1 ;# Fires trace\n# dl_deleteTrace myList $tr_id\n# dl_append myList 2 ;# Does NOT fire trace anymore",
    "see_also": ["dl_traceVariable (hypothetical)", "Tcl built-in 'trace' command"]
  },
  {
    "command": "dl_depth",
    "category": "Introspection",
    "synopsis": "dl_depth dynlist_name",
    "brief": "Returns the maximum nesting depth of a dynamic list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["The name of an existing dynamic list."]
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "Depth: 1 for a simple list, 2 for a list of simple lists, etc. An empty list (e.g. from dl_create) has depth 1. An empty list of lists (e.g. from dl_llist) has depth 2."
    },
    "errors": [
      "TCL_ERROR if dynlist_name does not refer to an existing dynamic list."
    ],
    "example": "set l1 [dl_create 1 2 3]              ;# depth 1\nset depth1 [dl_depth $l1]\n\nset l2 [dl_llist $l1 [dl_create 4 5]]  ;# depth 2 (list of simple lists)\nset depth2 [dl_depth $l2]\n\nset l3 [dl_llist $l2 [dl_llist [dl_create 6]]] ;# depth 3 (list of lists of lists)\nset depth3 [dl_depth $l3]\n\nset empty1 [dl_create]                   ;# depth 1\nset depth_e1 [dl_depth $empty1]\n\nset empty2 [dl_llist]                    ;# depth 2 (it's a DF_LIST, intended to hold lists)\nset depth_e2 [dl_depth $empty2]",
    "see_also": ["dl_datatype", "dl_length", "dl_llength", "dl_isMatrix"]
  },
  {
    "command": "dl_diff",
    "category": "Arithmetic / Data Analysis",
    "synopsis": "dl_diff dynlist_name [lag]",
    "brief": "Computes the element-wise difference between lagged elements of a numeric dynamic list (list[i+lag] - list[i]). Returns a new list.",
    "inputs": {
      "type": "varied",
      "length": "1-2",
      "element_types": ["string (dynlist_name)", "integer (lag, optional)"],
      "constraints": "Input list must be numeric and 1D. 'lag' must be a positive integer, defaults to 1 if omitted. List length must be greater than lag."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "numeric (promoted as necessary, e.g., to float)",
      "brief": "The resulting list will be shorter than the input list by 'lag' elements."
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found or is not a numeric list.",
      "TCL_ERROR if 'lag' is not a positive integer.",
      "TCL_ERROR if list length is not greater than 'lag'."
    ],
    "example": "set myList [dl_create 1 3 6 10 12.5]\nset diff1 [dl_diff $myList]        ;# lag=1, diff1 is [2.0 3.0 4.0 2.5]\nset diff2 [dl_diff $myList 2]    ;# lag=2, diff2 is [5.0 7.0 6.5]\n\nset intList [dl_ilist 10 20 25 30 40]\nset diff_int [dl_diff $intList]    ;# diff_int is [10 5 5 10]",
    "see_also": ["dl_idiff", "dl_sub", "dl_cumsum"]
  },
  {
    "command": "dl_dir",
    "category": "Introspection / Registry",
    "synopsis": "dl_dir [pattern]",
    "brief": "Returns a Tcl list of names of all currently defined dynamic lists. An optional glob pattern can be provided to filter the names.",
    "inputs": {
      "type": "string (pattern, optional)",
      "length": "0-1",
      "element_types": ["string (glob pattern)"],
      "constraints": "If provided, 'pattern' is used to filter the list names (e.g., \"%*\" for temporary lists)."
    },
    "returns": {
      "type": "TclList (of strings)",
      "new_object": true,
      "element_type": "string (dynlist name)",
      "brief": "A Tcl list where each element is the name of a dynamic list. The order is typically the order of creation or internal hash order."
    },
    "errors": [
      "TCL_ERROR if there is an issue accessing the dynamic list registry (very unlikely)."
    ],
    "example": "set a [dl_create 1]\nset b [dl_slist x y]\nset c [dl_ilist 10 20]\ndl_dir                 ;# Returns a Tcl list like: {a b c} (or %list0 %list1 %list2 if they got temp names)\ndl_dir %*              ;# Might return names of temporary lists if any exist and were not assigned to variables.",
    "see_also": ["dg_dir", "dl_exists", "dl_clean"]
  },
  {
    "command": "dl_div",
    "category": "Arithmetic",
    "synopsis": "dl_div dividend_list_or_val divisor_list_or_val [divisor2_list_or_val ...]",
    "brief": "Performs element-wise division. The dividend is divided by the first divisor, then the result by the second divisor, and so on. Returns a new list, typically of floats.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": "2+",
      "element_types": ["numeric"],
      "constraints": "Inputs must be numeric and broadcastable (e.g., same length or one is a scalar/1-element list). All divisor elements must be non-zero."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float (typically, to handle non-integer results and promote precision)"
    },
    "errors": [
      "TCL_ERROR if any input list is not found or not numeric.",
      "TCL_ERROR if lists are not compatible for division (cannot be broadcast).",
      "TCL_ERROR if division by zero is attempted for any element."
    ],
    "example": "set l1 [dl_create 10 20 30.0]\nset l2 [dl_create 2 5 2.0]\nset l3 [dl_div $l1 $l2]      ;# l3 is [5.0 4.0 15.0]\nset l4 [dl_div $l1 2]        ;# l4 is [5.0 10.0 15.0] (l1 divided by scalar 2)\nset l5 [dl_create 100]\nset l6 [dl_div $l5 $l1 $l2] ;# l6: (100/10)/2=5, (100/20)/5=1, (100/30)/2=1.666...",
    "see_also": ["dl_add", "dl_sub", "dl_mult", "dl_recip"]
  },
  {
    "command": "dl_dotimes",
    "category": "Control Structure",
    "synopsis": "dl_dotimes varName count_or_dynlist scriptBody",
    "brief": "A loop construct similar to Tcl's dotimes. Iterates 'scriptBody' a specified number of times, setting 'varName' to the current iteration index (0 to N-1). If 'count_or_dynlist' is a dynlist name, N is its length.",
    "inputs": {
      "type": "varied",
      "length": "3",
      "element_types": ["string (varName)", "integer_or_string (count_or_dynlist_name)", "string (scriptBody)"],
      "constraints": "'varName' is the iterator variable. 'count_or_dynlist_name' must be a non-negative integer or the name of an existing dynlist. 'scriptBody' is a Tcl script."
    },
    "returns": {
      "type": "string",
      "new_object": false,
      "brief": "The result of the last command executed in 'scriptBody' in the final iteration, or an empty string if the loop doesn't execute or 'scriptBody' is empty."
    },
    "side_effects": [
      "The variable 'varName' is set to the current iteration index (0-based) within the scope of 'scriptBody'.",
      "'scriptBody' is executed N times, potentially causing any Tcl side effects."
    ],
    "errors": [
      "TCL_ERROR if 'count_or_dynlist_name' is a dynlist name that is not found.",
      "TCL_ERROR if 'count_or_dynlist_name' does not evaluate to a non-negative integer (if not a dynlist name).",
      "TCL_ERROR if 'scriptBody' is syntactically incorrect.",
      "Errors from within the 'scriptBody' execution will propagate."
    ],
    "example": "set myList [dl_create a b c]\nset resultList [dl_create]\ndl_dotimes idx $myList {\n  dl_append $resultList [format \"Index: %d, Value: %[dl_get $myList $idx]%\"]\n}\n# resultList might contain: {\"Index: 0, Value: a\" \"Index: 1, Value: b\" \"Index: 2, Value: c\"}\n\ndl_dotimes i 3 { puts \"Iteration $i\" } ;# Prints Iteration 0, Iteration 1, Iteration 2",
    "see_also": ["dl_foreach", "Tcl built-in 'for'", "Tcl built-in 'while'", "Tcl built-in 'dotimes'"]
  },
  {
    "command": "dl_dump",
    "category": "Introspection / Debugging",
    "synopsis": "dl_dump dynlist_name [channelId]",
    "brief": "Prints the contents of a dynamic list to the specified Tcl channel or stdout. Useful for debugging.",
    "inputs": {
      "type": "varied",
      "length": "1-2",
      "element_types": ["string (dynlist_name)", "string (channelId, optional)"],
      "constraints": "'dynlist_name' must be an existing dynamic list. If 'channelId' is provided, it must be a valid writable Tcl channel (e.g., stdout, stderr, or a file channel). Defaults to stdout."
    },
    "returns": {
      "type": "void (TCL_OK on success)",
      "new_object": false
    },
    "side_effects": [
      "The contents of the dynamic list are printed to the specified channel or stdout.",
      "The output format depends on the list's data type and structure (e.g., numbers space-separated, strings possibly quoted, nested lists shown with braces)."
    ],
    "errors": [
      "TCL_ERROR if dynlist_name is not found.",
      "TCL_ERROR if channelId is provided but is not a valid writable Tcl channel."
    ],
    "example": "set myList [dl_create 1.0 2.5 -3.0]\ndl_dump $myList            ;# Prints to stdout, e.g., \"1.0 2.5 -3.0\n\"\n\nset myStrings [dl_slist hello \"world with spaces\"]\ndl_dump $myStrings         ;# Prints to stdout, e.g., {hello} {world with spaces}\n\nset f [open output.txt w]\ndl_dump $myList $f\nclose $f",
    "see_also": ["dg_dump", "dl_write", "dl_toString", "dl_get"]
  },
  {
    "command": "dl_dumpAsRow",
    "category": "Introspection / Debugging / Formatting",
    "synopsis": "dl_dumpAsRow dynlist_name [channelId] [delimiter]",
    "brief": "Prints the elements of a 1D dynamic list as a single row to a channel (default stdout), using an optional delimiter (default space).",
    "inputs": {
      "type": "varied",
      "length": "1-3",
      "element_types": ["string (dynlist_name)", "string (channelId, optional)", "string (delimiter, optional)"],
      "constraints": "'dynlist_name' must be an existing 1D dynamic list. 'channelId' defaults to stdout. 'delimiter' defaults to a single space."
    },
    "returns": {
      "type": "void (TCL_OK on success)",
      "new_object": false
    },
    "side_effects": [
      "Prints the list elements as a single line, separated by the delimiter, followed by a newline, to the specified channel."
    ],
    "errors": [
      "TCL_ERROR if dynlist_name is not found or is not a 1D list.",
      "TCL_ERROR if channelId is invalid."
    ],
    "example": "set rowData [dl_create 10 20 30 40]\ndl_dumpAsRow $rowData                ;# Prints to stdout: \"10 20 30 40\n\"\ndl_dumpAsRow $rowData stdout \",\"   ;# Prints to stdout: \"10,20,30,40\n\"\n\nset f [open row_output.txt w]\ndl_dumpAsRow $rowData $f \"\t\"    ;# Writes tab-separated values to file\nclose $f",
    "see_also": ["dl_dump", "dl_dumpMatrix", "dl_dumpMatrixInCols", "dl_writeAs"]
  },
  {
    "command": "dl_dumpMatrix",
    "category": "Introspection / Debugging / Formatting",
    "synopsis": "dl_dumpMatrix matrix_dynlist_name [channelId] [col_delimiter] [row_prefix] [row_suffix]",
    "brief": "Prints a 2D dynamic list (list of lists) in a matrix format to a channel (default stdout).",
    "inputs": {
      "type": "varied",
      "length": "1-5",
      "element_types": [
        "string (matrix_dynlist_name)",
        "string (channelId, optional)",
        "string (col_delimiter, optional)",
        "string (row_prefix, optional)",
        "string (row_suffix, optional)"
      ],
      "constraints": "'matrix_dynlist_name' must be a list of 1D lists (a 2D matrix). 'channelId' defaults to stdout. 'col_delimiter' defaults to space. 'row_prefix' and 'row_suffix' default to empty strings but can be e.g. '{' and '}'."
    },
    "returns": {
      "type": "void (TCL_OK on success)",
      "new_object": false
    },
    "side_effects": [
      "Prints the matrix row by row. Each row is prefixed by 'row_prefix', elements are separated by 'col_delimiter', and suffixed by 'row_suffix', followed by a newline."
    ],
    "errors": [
      "TCL_ERROR if matrix_dynlist_name is not found or is not a 2D list (list of 1D lists).",
      "TCL_ERROR if sublists are not 1D or have incompatible types for consistent printing.",
      "TCL_ERROR if channelId is invalid."
    ],
    "example": "set matrix [dl_llist [dl_create 1 2 3] [dl_create 4 5 6] [dl_create 7 8 9]]\ndl_dumpMatrix $matrix                        ;# Default: prints space separated, newlines between rows\n# Output:\n# 1 2 3\n# 4 5 6\n# 7 8 9\n\ndl_dumpMatrix $matrix stdout \",\" \"{\" \"}\"   ;# Prints CSV-like with braces\n# Output:\n# {1,2,3}\n# {4,5,6}\n# {7,8,9}",
    "see_also": ["dl_dump", "dl_dumpAsRow", "dl_dumpMatrixInCols", "dl_isMatrix"]
  },
  {
    "command": "dl_dumpMatrixInCols",
    "category": "Introspection / Debugging / Formatting",
    "synopsis": "dl_dumpMatrixInCols matrix_dynlist_name [channelId] [col_delimiter] [options...]",
    "brief": "Prints a 2D dynamic list (matrix) to a channel (default stdout) with elements aligned in columns. Assumes sublists (rows) have equal length.",
    "inputs": {
      "type": "varied",
      "length": "1+",
      "element_types": [
        "string (matrix_dynlist_name)",
        "string (channelId, optional)",
        "string (col_delimiter, optional)",
        "string (various_options_for_formatting, optional)"
      ],
      "constraints": "'matrix_dynlist_name' must be a list of 1D lists with equal lengths. 'channelId' defaults to stdout. 'col_delimiter' defaults to one or more spaces for alignment. Options might control padding, justification etc."
    },
    "returns": {
      "type": "void (TCL_OK on success)",
      "new_object": false
    },
    "side_effects": [
      "Prints the matrix with elements formatted into aligned columns. Each row of the input matrix corresponds to a line of output."
    ],
    "errors": [
      "TCL_ERROR if matrix_dynlist_name is not found or is not a 2D list.",
      "TCL_ERROR if sublists (rows) have inconsistent lengths, making columnar display ambiguous.",
      "TCL_ERROR if channelId is invalid.",
      "TCL_ERROR for invalid formatting options."
    ],
    "example": "set m [dl_llist [dl_slist Name Age City] [dl_slist Alice 30 London] [dl_slist Bob 24 Paris] [dl_slist Charles 45 Berlin]]\ndl_dumpMatrixInCols $m stdout \"  \" ;# Use two spaces as delimiter for potential padding\n# Expected Output (actual spacing depends on implementation):\n# Name     Age  City  \n# Alice    30   London\n# Bob      24   Paris \n# Charles  45   Berlin",
    "see_also": ["dl_dumpMatrix", "dl_dumpAsRow", "dl_transpose"]
  },
  {
    "command": "dl_eq",
    "category": "Logical / Comparison",
    "synopsis": "dl_eq list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise equality (==) comparison. If more than two arguments, it checks chained equality (e.g., a==b AND b==c). Returns a new list of 0s (false) and 1s (true).",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable (Tcl's comparison rules apply, which can be flexible with types)."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "Result contains 0 (false) or 1 (true) for each element-wise comparison."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists are not compatible for comparison (cannot be broadcast)."
    ],
    "example": "set l1 [dl_create 1 2 3 2 5]\nset l2 [dl_create 1 2 4 2 0]\nset res1 [dl_eq $l1 $l2]   ;# res1 is [1 1 0 1 0]\nset res2 [dl_eq $l1 2]     ;# res2 is [0 1 0 1 0] (l1 compared to scalar 2)\n\nset s1 [dl_slist a b c]\nset s2 [dl_slist a d c]\nset res3 [dl_eq $s1 $s2]   ;# res3 is [1 0 1]\n\nset l3 [dl_create 2 2 2]\nset res4 [dl_eq $l1 $l3 2] ;# res4 (l1==l3 and l3==2) is [0 1 0 1 0] AND [1 1 1] broadcast with 2 -> [0 1 0 0 0] (assuming strict element-wise for chained)",
    "see_also": ["dl_noteq", "dl_gt", "dl_lt", "dl_gte", "dl_lte", "dl_and", "dl_or"]
  },
  {
    "command": "dl_eqIndex",
    "category": "Logical / Comparison / Indexing",
    "synopsis": "dl_eqIndex list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise equality (==) comparison and returns a new list containing the 0-based indices where the result is true. If more than two arguments, it checks chained equality.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable (Tcl's comparison rules apply)."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 0-based indices where the comparison is true."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists are not compatible for comparison (cannot be broadcast)."
    ],
    "example": "set l1 [dl_create 10 20 30 20 10]\nset l2 [dl_create 10 25 30 20 15]\nset idx1 [dl_eqIndex $l1 $l2]  ;# idx1 is [0 2 3]\nset idx2 [dl_eqIndex $l1 20]  ;# idx2 is [1 3]\n\nset s1 [dl_slist x y z y x]\nset s2 [dl_slist x a z y k]\nset idx3 [dl_eqIndex $s1 $s2]  ;# idx3 is [0 2 3]\n\nset l3 [dl_create 20 20 20]\nset idx4 [dl_eqIndex $l1 $l3 20] ;# (l1==l3 AND l3==20). l1==l3 -> [0 1 0 1 0] (after broadcast). l3==20 -> [1 1 1]. Resulting indices from [0 1 0 1 0] AND ([1 1 1] broadcasted) -> indices where both are true for $l1: [1 3]",
    "see_also": ["dl_eq", "dl_noteqIndex", "dl_gtIndex", "dl_ltIndex", "dl_andIndex", "dl_orIndex", "dl_select"]
  },
  {
    "command": "dl_exists",
    "category": "Introspection / Registry",
    "synopsis": "dl_exists dynlist_name",
    "brief": "Checks if a dynamic list with the specified name exists in the current interpreter.",
    "inputs": {
      "type": "string",
      "length": 1,
      "element_types": ["string (dynlist_name)"],
      "constraints": "'dynlist_name' is the name to check for existence."
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "Returns 1 if the dynamic list exists, 0 otherwise."
    },
    "errors": [
      "TCL_ERROR if the wrong number of arguments is provided (expects exactly one argument)."
    ],
    "example": "set myList [dl_create 1 2 3]\nif {[dl_exists $myList]} {\n  puts \"myList exists!\"\n} else {\n  puts \"myList does not exist.\"\n}\n# Output: myList exists!\n\ndl_delete $myList\nputs [dl_exists $myList] ;# Output: 0\n\nputs [dl_exists some_nonexistent_list] ;# Output: 0",
    "see_also": ["dg_exists", "dl_dir", "dl_datatype", "dl_delete"]
  },
  {
    "command": "dl_exp",
    "category": "Arithmetic / Transcendental",
    "synopsis": "dl_exp dynlist_name | dl_exp number",
    "brief": "Computes the element-wise natural exponential (e^x) of a dynamic list or a single number. Returns a new list of floats.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float"
    },
    "errors": [
      "TCL_ERROR if input list is not found or is a string list.",
      "TCL_ERROR for math errors such as overflow for large input values."
    ],
    "example": "set values [dl_create 0 1 2 -1 0.5]\nset exp_values [dl_exp $values] ;# exp_values approx [1.0 2.718 7.389 0.367 1.648]\ndl_exp 3 ;# Returns a new list containing e^3 (approx 20.085)",
    "see_also": ["dl_log", "dl_log10", "dl_pow", "dl_sqrt"]
  },
  {
    "command": "dl_fill",
    "category": "Creation",
    "synopsis": "dl_fill count value [-type type_string]",
    "brief": "Creates a new dynamic list of 'count' elements, all initialized to 'value'. An optional type can be specified.",
    "inputs": {
      "type": "varied",
      "length": "2-4",
      "element_types": ["integer (count)", "any (value)", "string (-type, optional literal)", "string (type_string, e.g. int, float, string, optional)"],
      "constraints": "'count' must be a non-negative integer. 'value' is the fill value. If '-type' is used, 'type_string' specifies the list type; otherwise, type is inferred from 'value'."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "any (matches 'value' type or specified by '-type')"
    },
    "errors": [
      "TCL_ERROR if 'count' is not a non-negative integer.",
      "TCL_ERROR if 'value' cannot be converted/used for the specified or inferred type.",
      "TCL_ERROR if an invalid 'type_string' is provided with '-type'.",
      "TCL_ERROR for incorrect number of arguments."
    ],
    "example": "set list1 [dl_fill 5 0]          ;# list1 is an integer list: [0 0 0 0 0]\nset list2 [dl_fill 3 1.2]        ;# list2 is a float list: [1.2 1.2 1.2]\nset list3 [dl_fill 4 hello -type string] ;# list3 is a string list: [hello hello hello hello]\nset list4 [dl_fill 2 true -type int] ;# list4 might be [1 1] if true converts to 1 for int type",
    "see_also": ["dl_create", "dl_zeros", "dl_ones", "dl_repeat"]
  },
  {
    "command": "dl_find",
    "category": "Searching",
    "synopsis": "dl_find source_dynlist_name search_item_name_or_value [start_index]",
    "brief": "Finds the first occurrence of a search item (sublist or value) within a source dynamic list. Returns the 0-based starting index or -1 if not found.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["string (source_dynlist_name)", "string_or_any (search_item_name_or_value)", "integer (start_index, optional)"],
      "constraints": "'search_item_name_or_value' can be a dynlist name or a literal value. 'start_index' defaults to 0."
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "0-based index of the first match, or -1 if not found."
    },
    "errors": [
      "TCL_ERROR if source_dynlist or search_item (if a list name) is not found.",
      "TCL_ERROR if start_index is not a valid integer or is out of bounds.",
      "TCL_ERROR if types are incompatible for comparison."
    ],
    "example": "set mainList [dl_create a b c a b d e]\nset subList [dl_create a b]\nset idx1 [dl_find $mainList $subList]       ;# idx1 is 0\nset idx2 [dl_find $mainList $subList 1]     ;# idx2 is 3 (starts search from index 1)\nset idx3 [dl_find $mainList c]             ;# idx3 is 2\nset idx4 [dl_find $mainList x]             ;# idx4 is -1 (not found)\\n\\nset numList [dl_ilist 10 20 30 10 20 40]\nset searchNums [dl_ilist 10 20]\nset idx5 [dl_find $numList $searchNums]   ;# idx5 is 0\nset idx6 [dl_find $numList 30 1]         ;# idx6 is 2",
    "see_also": ["dl_findAll", "dl_findIndices", "dl_countOccurences", "dl_firstPos", "dl_stringmatch"]
  },
  {
    "command": "dl_findAll",
    "category": "Searching",
    "synopsis": "dl_findAll source_dynlist_name search_item_name_or_value [start_index]",
    "brief": "Finds all non-overlapping occurrences of a search item (sublist or value) within a source dynamic list. Returns a new list of 0-based starting indices.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["string (source_dynlist_name)", "string_or_any (search_item_name_or_value)", "integer (start_index, optional)"],
      "constraints": "'search_item_name_or_value' can be a dynlist name or a literal value. 'start_index' defaults to 0."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A new list of 0-based indices of all non-overlapping matches. Empty list if no matches found."
    },
    "errors": [
      "TCL_ERROR if source_dynlist or search_item (if a list name) is not found.",
      "TCL_ERROR if start_index is not a valid integer or is out of bounds.",
      "TCL_ERROR if types are incompatible for comparison."
    ],
    "example": "set mainList [dl_create a b c a b d a b c e]\nset subList [dl_create a b]\nset indices1 [dl_findAll $mainList $subList]    ;# indices1 is [0 3 6]\nset indices2 [dl_findAll $mainList $subList 1]  ;# indices2 is [3 6]\nset indices3 [dl_findAll $mainList c]          ;# indices3 is [2 8]\nset indices4 [dl_findAll $mainList x]          ;# indices4 is [] (empty list)",
    "see_also": ["dl_find", "dl_findIndices", "dl_countOccurences", "dl_regexp"]
  },
  {
    "command": "dl_findIndices",
    "category": "Searching / Indexing",
    "synopsis": "dl_findIndices source_dynlist_name search_item_name_or_value [start_index] [-all]",
    "brief": "Finds occurrences of a search item (sublist or value) within a source dynamic list and returns their 0-based starting indices. By default, finds all non-overlapping occurrences.",
    "inputs": {
      "type": "varied",
      "length": "2-4",
      "element_types": ["string (source_dynlist_name)", "string_or_any (search_item_name_or_value)", "integer (start_index, optional)", "string (-all, optional literal flag)"],
      "constraints": "'search_item_name_or_value' can be a dynlist name or a literal. 'start_index' defaults to 0. The '-all' flag is often implied if not other mode specified."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A new list of 0-based indices. Typically all non-overlapping matches. Behavior might vary if other mode flags were supported (e.g. -first)."
    },
    "errors": [
      "TCL_ERROR if source_dynlist or search_item (if a list name) is not found.",
      "TCL_ERROR if start_index is not a valid integer or is out of bounds.",
      "TCL_ERROR if types are incompatible for comparison or invalid option provided."
    ],
    "example": "set data [dl_slist apple pear banana apple grape apple orange]\nset query apple\nset all_idx [dl_findIndices $data $query]          ;# all_idx is [0 3 5]\nset from_two [dl_findIndices $data $query 2]     ;# from_two is [3 5]\n\nset list_q [dl_slist grape apple]\nset found_list_idx [dl_findIndices $data $list_q] ;# found_list_idx is [4]",
    "see_also": ["dl_find", "dl_findAll", "dl_countOccurences", "dl_regexp", "dl_select"]
  },
  {
    "command": "dl_findPatterns",
    "category": "Searching / Regular Expressions",
    "synopsis": "dl_findPatterns source_dynlist_name regexp_pattern [regexp_options...]",
    "brief": "Finds elements in a string dynamic list that match a Tcl regular expression. Returns a list of 0-based indices of matching elements.",
    "inputs": {
      "type": "varied",
      "length": "2+",
      "element_types": ["string (source_dynlist_name)", "string (regexp_pattern)", "string (regexp_option, optional) ..."],
      "constraints": "'source_dynlist_name' should contain string elements. 'regexp_pattern' is a Tcl regular expression. Supported 'regexp_options' are those compatible with Tcl's regexp command when used for matching elements (e.g., -nocase)."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A new list of 0-based indices of elements in source_dynlist that matched the pattern. Empty if no matches."
    },
    "errors": [
      "TCL_ERROR if source_dynlist is not found or its elements are not strings.",
      "TCL_ERROR if regexp_pattern is invalid.",
      "TCL_ERROR for invalid regexp_options."
    ],
    "example": "set myStrings [dl_slist Apple Pears Banana Apricot GRAPE]\nset pattern {^[Aa].*} ;# Starts with A or a\nset matching_indices [dl_findPatterns $myStrings $pattern] ;# matching_indices is [0 3]\n\nset pattern2 {GRA.E}\nset case_sensitive_idx [dl_findPatterns $myStrings $pattern2]      ;# case_sensitive_idx is [4]\nset case_insensitive_idx [dl_findPatterns $myStrings $pattern2 -nocase] ;# case_insensitive_idx is [4] (assuming GRAPE is the only match)\\n\\nset files [dl_slist file1.txt data.csv image.png script.tcl notes.TXT]\nset txt_pattern {\\\\.txt$} ;# Escaped dot for literal dot, then end of string\nset txt_indices [dl_findPatterns $files $txt_pattern -nocase] ;# txt_indices is [0 4]",
    "see_also": ["dl_regexp", "dl_stringmatch", "dl_find", "dl_findAll", "Tcl built-in regexp"]
  },
  {
    "command": "dl_first",
    "category": "Accessing Elements",
    "synopsis": "dl_first dynlist_name",
    "brief": "Returns the first element of a dynamic list. If the list is a list of lists, it returns the name of the first sublist.",
    "inputs": {
      "type": "string",
      "length": 1,
      "element_types": ["string (dynlist_name)"],
      "constraints": "The dynamic list must not be empty."
    },
    "returns": {
      "type": "any_or_string (dynlist_name)",
      "new_object": false,
      "brief": "The first element of the list, or the name of the first sublist if it's a list of lists."
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found.",
      "TCL_ERROR if the list is empty.",
      "TCL_ERROR if the wrong number of arguments is provided."
    ],
    "example": "set myList [dl_create apple banana cherry]\nset first_item [dl_first $myList]   ;# first_item is \"apple\"\n\nset myNums [dl_ilist 10 20 30]\nset first_num [dl_first $myNums]     ;# first_num is 10\n\nset sub1 [dl_create 1 2]\nset sub2 [dl_create 3 4]\nset lol [dl_llist $sub1 $sub2]\nset first_sublist_name [dl_first $lol] ;# first_sublist_name is the name of sub1 (e.g., %list0)",
    "see_also": ["dl_last", "dl_get", "dl_index", "dl_pickone"]
  },
  {
    "command": "dl_firstPos",
    "category": "Searching / Indexing",
    "synopsis": "dl_firstPos dynlist_name value_to_find [start_index]",
    "brief": "Returns the 0-based index of the first occurrence of a specific 'value_to_find' in a dynamic list. Returns -1 if not found.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["string (dynlist_name)", "any (value_to_find)", "integer (start_index, optional)"],
      "constraints": "'value_to_find' must be a literal value comparable with list elements. 'start_index' defaults to 0."
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "0-based index of the first occurrence of the value, or -1 if not found."
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found.",
      "TCL_ERROR if start_index is invalid (e.g., out of bounds, not an integer).",
      "TCL_ERROR if value_to_find cannot be compared with list elements."
    ],
    "example": "set myList [dl_create a b c a b d a b c e]\nset pos1 [dl_firstPos $myList a]          ;# pos1 is 0\nset pos2 [dl_firstPos $myList a 1]        ;# pos2 is 3 (starts search from index 1)\nset pos3 [dl_firstPos $myList c]          ;# pos3 is 2\nset pos4 [dl_firstPos $myList x]          ;# pos4 is -1\\n\\nset myNums [dl_ilist 10 20 10 30 10]\nset num_pos1 [dl_firstPos $myNums 10]     ;# num_pos1 is 0\nset num_pos2 [dl_firstPos $myNums 10 1]   ;# num_pos2 is 2",
    "see_also": ["dl_find", "dl_findAll", "dl_lastPos", "dl_index"]
  },
  {
    "command": "dl_first_index_list",
    "category": "Searching / Indexing",
    "synopsis": "dl_first_index_list source_dynlist_name search_values_dynlist_name [start_index]",
    "brief": "Finds the 0-based index of the first element in 'source_dynlist' that matches any value present in 'search_values_dynlist'. Returns -1 if no match found.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["string (source_dynlist_name)", "string (search_values_dynlist_name)", "integer (start_index, optional)"],
      "constraints": "Both inputs must be valid dynlist names. 'start_index' defaults to 0."
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "0-based index in source_dynlist of the first match, or -1."
    },
    "errors": [
      "TCL_ERROR if source_dynlist_name or search_values_dynlist_name not found.",
      "TCL_ERROR if start_index is invalid.",
      "TCL_ERROR if elements are not comparable between lists."
    ],
    "example": "set sourceList [dl_slist a b c d e f c a g]\nset searchFor [dl_slist x c e z]\nset first_idx [dl_first_index_list $sourceList $searchFor]    ;# first_idx is 2 (due to 'c')\nset first_idx_from_3 [dl_first_index_list $sourceList $searchFor 3] ;# first_idx_from_3 is 4 (due to 'e', search started after 'c' at index 2)\\n\\nset emptySearch [dl_slist k l m]\nset no_match_idx [dl_first_index_list $sourceList $emptySearch] ;# no_match_idx is -1",
    "see_also": ["dl_find", "dl_firstPos", "dl_index_list", "dl_oneof"]
  },
  {
    "command": "dl_flist",
    "category": "Creation",
    "synopsis": "dl_flist [value1 value2 ... | {value_list} | dynlist_name1 dynlist_name2 ...]",
    "brief": "Creates a new dynamic list of type float (double precision). Initializes with optional values, converting them to floats.",
    "inputs": {
      "type": "varied (numeric values, Tcl list, or dynlist names)",
      "length": "0+",
      "element_types": ["numeric (value_to_convert_to_float)", "Tcl list of numeric values", "string (dynlist_name_of_numeric_list)"],
      "constraints": "All inputs will be converted to float. Non-numeric inputs will cause an error."
    },
    "returns": {
      "type": "string (name of new float DynList)",
      "new_object": true,
      "element_type": "float (double precision)"
    },
    "errors": [
      "TCL_ERROR if any input value cannot be converted to a float.",
      "TCL_ERROR if a named dynlist argument is not found or contains non-numeric data."
    ],
    "example": "set floatList1 [dl_flist 1 2.5 3]        ;# floatList1 is [1.0 2.5 3.0]\nset floatList2 [dl_flist {0.0 -1.1 5}]    ;# floatList2 is [0.0 -1.1 5.0]\nset intList [dl_ilist 10 20]\nset floatList3 [dl_flist $intList 30.3]  ;# floatList3 is [10.0 20.0 30.3]\nset emptyFloats [dl_flist]                ;# Creates an empty float list",
    "see_also": ["dl_create", "dl_ilist", "dl_slist", "dl_clist", "dl_llist", "dl_float"]
  },
  {
    "command": "dl_float",
    "category": "Conversion / Creation",
    "synopsis": "dl_float source_data [output_var_name]",
    "brief": "Converts elements of 'source_data' (dynlist name, Tcl list, or literal values) to float type, returning a new float dynlist. Optionally stores the new list's name in 'output_var_name'.",
    "inputs": {
      "type": "varied",
      "length": "1-2",
      "element_types": ["string_or_list_or_values (source_data)", "string (output_var_name, optional)"],
      "constraints": "'source_data' can be a dynlist name, a Tcl list of numeric values, or individual numeric values. All inputs are converted to float."
    },
    "returns": {
      "type": "string (name of new float DynList)",
      "new_object": true,
      "element_type": "float (double precision)"
    },
    "side_effects": [
      "If 'output_var_name' is provided, the Tcl variable by that name is set to the name of the new float dynlist."
    ],
    "errors": [
      "TCL_ERROR if source_data contains values that cannot be converted to float.",
      "TCL_ERROR if source_data is a dynlist name that is not found.",
      "TCL_ERROR if output_var_name is invalid (if used)."
    ],
    "example": "set intList [dl_ilist 1 2 30]\nset floatList1 [dl_float $intList]            ;# floatList1 is [1.0 2.0 30.0]\\n\\ndl_float {5 6.6 7} newFloatListName          ;# newFloatListName holds name of [5.0 6.6 7.0]\nputs [dl_dump $newFloatListName]                ;# (dl_dump to verify contents if needed)\\n\\nset floatList2 [dl_float 100 101.5]           ;# floatList2 is [100.0 101.5]",
    "see_also": ["dl_flist", "dl_int", "dl_char", "dl_stringmatch", "dl_convert"]
  },
  {
    "command": "dl_floor",
    "category": "Arithmetic",
    "synopsis": "dl_floor dynlist_name | dl_floor number",
    "brief": "Computes the element-wise floor of a dynamic list or number (largest integer less than or equal to each value). Returns a new list.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer (or float representing an integer, e.g., 2.0)"
    },
    "errors": [
      "TCL_ERROR if input list is not found, is a string list, or for general math errors."
    ],
    "example": "set myList [dl_create 1.7 2.0 -3.2 4.99]\nset floorList [dl_floor $myList] ;# floorList will be [1.0 2.0 -4.0 4.0] (or integer equivalents)\ndl_floor -5.5 ;# returns a new list containing [-6.0]",
    "see_also": ["dl_ceil", "dl_round", "dl_int", "dl_trunc"]
  },
  {
    "command": "dl_fmod",
    "category": "Arithmetic",
    "synopsis": "dl_fmod dividend_list_or_val divisor_list_or_val",
    "brief": "Computes the element-wise floating-point remainder of x/y. The result has the same sign as x. Returns a new list of floats.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 2,
      "element_types": ["numeric", "numeric"],
      "constraints": "Inputs must be numeric and broadcastable. Divisor elements must be non-zero."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float"
    },
    "errors": [
      "TCL_ERROR if any input list is not found or not numeric.",
      "TCL_ERROR if lists are not compatible for the operation (cannot be broadcast).",
      "TCL_ERROR if division by zero is attempted for any element."
    ],
    "example": "set l1 [dl_create 5.0 -5.0 5.0 -5.0 2.7]\nset l2 [dl_create 3.0 3.0 -3.0 -3.0 1.3]\nset res [dl_fmod $l1 $l2]  ;# res is [2.0 -2.0 2.0 -2.0 0.1] (approx for last element)\n\nset res2 [dl_fmod $l1 2.5] ;# res2 is [0.0 -0.0 0.0 -0.0 0.2] (signs from dividend)",
    "see_also": ["dl_mod", "dl_div"]
  },
  {
    "command": "dl_foreach",
    "category": "Control Structure / Iteration",
    "synopsis": "dl_foreach varlist1 dynlist_name1 [varlist2 dynlist_name2 ...] scriptBody",
    "brief": "Iterates over one or more dynamic lists, assigning elements to loop variables. Similar to Tcl's built-in foreach.",
    "inputs": {
      "type": "varied",
      "length": "3+",
      "element_types": ["string (varlist, e.g. x or {x y})", "string (dynlist_name)", "... (more varlist/dynlist_name pairs, optional)", "string (scriptBody)"],
      "constraints": "Each 'varlist' contains one or more Tcl variable names. Each 'dynlist_name' must be an existing dynamic list. 'scriptBody' is a Tcl script."
    },
    "returns": {
      "type": "string",
      "new_object": false,
      "brief": "The result of the last command in 'scriptBody' from the final iteration, or an empty string."
    },
    "side_effects": [
      "Loop variables in 'varlist(s)' are set to elements from the corresponding 'dynlist(s)' for each iteration within 'scriptBody'.",
      "If a dynlist is shorter, its corresponding variables might receive empty strings in later iterations (Tcl standard behavior)."
    ],
    "errors": [
      "TCL_ERROR if any dynlist_name is not found.",
      "TCL_ERROR if varlist structure is invalid or does not match list iteration needs.",
      "TCL_ERROR if scriptBody is syntactically incorrect or an error occurs during its execution."
    ],
    "example": "set names [dl_slist Alice Bob Charles]\nset ages [dl_ilist 30 25 40]\nset cities [dl_slist London Paris Berlin]\n\ndl_foreach name $names age $ages city $cities {\n  puts \"Name: $name, Age: $age, City: $city\"\n}\n# Output:\n# Name: Alice, Age: 30, City: London\n# Name: Bob, Age: 25, City: Paris\n# Name: Charles, Age: 40, City: Berlin\n\nset numbers [dl_create 1 2 3 4 5]\nset sum 0\ndl_foreach n $numbers { incr sum $n }\nputs \"Sum: $sum\" ;# Output: Sum: 15",
    "see_also": ["dl_dotimes", "Tcl built-in foreach", "Tcl built-in for", "Tcl built-in while"]
  },
  {
    "command": "dl_fromto",
    "category": "Creation / Sequence Generation",
    "synopsis": "dl_fromto start end [step]",
    "brief": "Creates a new dynamic list containing a sequence of numbers from 'start' to 'end' with a specified 'step'.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["numeric (start_value)", "numeric (end_value)", "numeric (step_value, optional)"],
      "constraints": "'start', 'end', and 'step' must be numeric. 'step' defaults to 1 if start <= end, or -1 if start > end. 'step' cannot be 0."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "integer or float (depending on input types and step resulting in whole numbers)"
    },
    "errors": [
      "TCL_ERROR if inputs are not numeric.",
      "TCL_ERROR if step is 0.",
      "TCL_ERROR if step direction contradicts start/end relationship (e.g., start < end but step is negative), unless it produces an empty list."
    ],
    "example": "set seq1 [dl_fromto 1 5]         ;# seq1 is [1 2 3 4 5] (integer or float)\nset seq2 [dl_fromto 0 10 2.5]     ;# seq2 is [0.0 2.5 5.0 7.5 10.0]\nset seq3 [dl_fromto 5 1]         ;# seq3 is [5 4 3 2 1]\nset seq4 [dl_fromto 1.0 3.5 0.5]   ;# seq4 is [1.0 1.5 2.0 2.5 3.0 3.5]\nset seq5 [dl_fromto 1 1]         ;# seq5 is [1]",
    "see_also": ["dl_create", "dl_fill", "dl_series", "Tcl built-in for"]
  },
  {
    "command": "dl_gaussian2D",
    "category": "Creation / Image Processing / Kernel Generation",
    "synopsis": "dl_gaussian2D size_x size_y sigma_x sigma_y [theta_rad] [center_x] [center_y] [normalize]",
    "brief": "Generates a 2D Gaussian kernel as a list of float lists.",
    "inputs": {
      "type": "varied",
      "length": "4-8",
      "element_types": [
        "integer (size_x)",
        "integer (size_y)",
        "float (sigma_x)",
        "float (sigma_y)",
        "float (theta_rad, optional)",
        "float (center_x, optional)",
        "float (center_y, optional)",
        "integer_or_boolean (normalize, optional)"
      ],
      "constraints": "size_x, size_y > 0. sigma_x, sigma_y > 0. theta_rad defaults to 0. center_x/y default to middle of kernel. normalize defaults to 1 (true)."
    },
    "returns": {
      "type": "string (name of new 2D DynList)",
      "new_object": true,
      "element_type": "list (of float lists)"
    },
    "errors": [
      "TCL_ERROR if size_x, size_y are not positive integers.",
      "TCL_ERROR if sigma_x, sigma_y are not positive floats.",
      "TCL_ERROR if optional arguments are not valid numbers/booleans.",
      "TCL_ERROR for memory allocation failures."
    ],
    "example": "set kernel1 [dl_gaussian2D 5 5 1.0 1.0] ;# 5x5 kernel, sigma=1.0, normalized\n# kernel1 will be a list of 5 float lists.\n\nset kernel2 [dl_gaussian2D 3 7 0.5 1.5 0.785 0 0 0] ;# 3x7, sigmas 0.5,1.5, rotated PI/4, centered at (0,0) of kernel, not normalized",
    "see_also": ["dl_llist", "dl_flist", "dl_conv", "dl_create"]
  },
  {
    "command": "dl_generateDynList",
    "category": "Creation / Advanced",
    "synopsis": "dl_generateDynList count script_body [type_hint]",
    "brief": "Generates a dynamic list of 'count' elements by repeatedly executing 'script_body'. The script can use an implicit loop variable (e.g., $i) for the current index.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["integer (count)", "string (script_body)", "string (type_hint, optional, e.g., int, float, string)"],
      "constraints": "'count' must be a non-negative integer. 'script_body' is a Tcl script executed 'count' times. It can access a variable (e.g. $dl_generate_idx) for the current 0-based index. The script should return the element for that position."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "any (inferred from script results or based on type_hint)"
    },
    "errors": [
      "TCL_ERROR if 'count' is not a non-negative integer.",
      "TCL_ERROR if 'script_body' is syntactically incorrect or errors during execution.",
      "TCL_ERROR if script results are of inconsistent types and no unambiguous type can be determined, or if they conflict with 'type_hint'."
    ],
    "example": "# Generate a list of squares: 0 1 4 9 16\nset squares [dl_generateDynList 5 {expr {$dl_generate_idx * $dl_generate_idx}} int]\\n\\n# Generate a list of strings: item_0 item_1 item_2\nset items [dl_generateDynList 3 {return \\\"item_$dl_generate_idx\\\"} string]\\n\\n# Generate a list of random floats between 0 and 1\nset randFloats [dl_generateDynList 4 {expr {rand()}} float]",
    "see_also": ["dl_create", "dl_fill", "dl_fromto", "dl_dotimes", "Tcl built-in lgenerate"]
  },
  {
    "command": "dl_get",
    "category": "Accessing Elements",
    "synopsis": "dl_get dynlist_name index1 [index2 ...]",
    "brief": "Retrieves an element or sublist from a dynamic list using one or more 0-based indices. Returns the element value or the name of the sublist.",
    "inputs": {
      "type": "varied",
      "length": "2+",
      "element_types": ["string (dynlist_name)", "integer (index1)", "integer (index2, optional)", "..."],
      "constraints": "'dynlist_name' must be an existing list. Indices must be 0-based integers and within bounds for each list level."
    },
    "returns": {
      "type": "any_or_string (dynlist_name)",
      "new_object": false,
      "brief": "The value of the element at the specified index(es). If the element is a sublist, its name (a string) is returned."
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found.",
      "TCL_ERROR if any index is not an integer or is out of bounds.",
      "TCL_ERROR if too many indices are provided for the list's depth."
    ],
    "example": "set myList [dl_create apple banana cherry]\nset item1 [dl_get $myList 1]       ;# item1 is \"banana\"\n\nset myNums [dl_ilist 10 20 30 40]\nset num_val [dl_get $myNums 0]    ;# num_val is 10\n\nset sub1 [dl_create 1 2]\nset sub2 [dl_slist x y z]\nset lol [dl_llist $sub1 $sub2]\nset sublist_name [dl_get $lol 0]   ;# sublist_name is the name of sub1 (e.g., %listN)\nset deep_item [dl_get $lol 1 2]    ;# deep_item is \"z\" (from sub2 at index 1 of lol, then index 2 of sub2)",
    "see_also": ["dl_first", "dl_last", "dl_index", "dl_put", "dl_set", "dl_sublist"]
  },
  {
    "command": "dl_gt",
    "category": "Logical / Comparison",
    "synopsis": "dl_gt list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise greater than (>) comparison. If more than two arguments, checks chained comparison (e.g., a>b AND b>c). Returns a new list of 0s and 1s.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "Result contains 0 (false) or 1 (true) for each element-wise comparison."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists/values are not compatible for comparison (cannot be broadcast or compared)."
    ],
    "example": "set l1 [dl_create 5 2 8 1 9]\nset l2 [dl_create 3 7 8 0 2]\nset res1 [dl_gt $l1 $l2]   ;# res1 is [1 0 0 1 1]\nset res2 [dl_gt $l1 4]     ;# res2 is [1 0 1 0 1] (l1 compared to scalar 4)\\n\\nset l3 [dl_create 1 1 1]\n# For chained: (l1 > l3) AND (l3 > 0), assuming l3 broadcast against l1, and then scalar 0 against intermediate result\nset res3 [dl_gt $l1 $l3 0] ;# Example: l1[0]=5, l3[0]=1 -> (5>1 AND 1>0) -> 1. l1[1]=2, l3[1]=1 -> (2>1 AND 1>0) -> 1. l1[3]=1, l3[any]=1 -> (1>1 is false) -> 0",
    "see_also": ["dl_lt", "dl_gte", "dl_lte", "dl_eq", "dl_noteq", "dl_gtIndex"]
  },
  {
    "command": "dl_gtIndex",
    "category": "Logical / Comparison / Indexing",
    "synopsis": "dl_gtIndex list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise greater than (>) comparison and returns a new list of 0-based indices where true. For chained comparisons (e.g. a>b AND b>c), indices are where the entire chain is true.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 0-based indices where the comparison is true."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists/values are not compatible for comparison (cannot be broadcast or compared)."
    ],
    "example": "set l1 [dl_create 5 2 8 1 9]\nset l2 [dl_create 3 7 8 0 2]\nset idx1 [dl_gtIndex $l1 $l2] ;# idx1 is [0 3 4]\nset idx2 [dl_gtIndex $l1 4]   ;# idx2 is [0 2 4]\\n\\nset l3 [dl_create 1 1 1]\n# For chained: (l1 > l3) AND (l3 > 0)\nset idx3 [dl_gtIndex $l1 $l3 0] ;# Example: l1[0]=5,l3[0]=1 -> (5>1 AND 1>0) -> true, index 0. l1[1]=2,l3[1]=1 -> (2>1 AND 1>0) -> true, index 1. l1[3]=1,l3[any]=1 -> (1>1 is false) -> false",
    "see_also": ["dl_gt", "dl_ltIndex", "dl_gteIndex", "dl_lteIndex", "dl_eqIndex", "dl_noteqIndex"]
  },
  {
    "command": "dl_gte",
    "category": "Logical / Comparison",
    "synopsis": "dl_gte list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise greater than or equal to (>=) comparison. For chained, e.g., a>=b AND b>=c. Returns list of 0s/1s.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "Result contains 0 (false) or 1 (true) for each element-wise comparison."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists/values are not compatible for comparison (cannot be broadcast or compared)."
    ],
    "example": "set l1 [dl_create 5 2 8 1 9]\nset l2 [dl_create 3 2 8 0 10]\nset res1 [dl_gte $l1 $l2]  ;# res1 is [1 1 1 1 0]\nset res2 [dl_gte $l1 5]    ;# res2 is [1 0 1 0 1]\\n\\nset l3 [dl_create 2 2 2]\n# Chained: (l1 >= l3) AND (l3 >= 2)\nset res3 [dl_gte $l1 $l3 2] ;# e.g. l1[0]=5,l3[0]=2 -> (5>=2 AND 2>=2) -> 1",
    "see_also": ["dl_gt", "dl_lt", "dl_lte", "dl_eq", "dl_noteq", "dl_gteIndex"]
  },
  {
    "command": "dl_gteIndex",
    "category": "Logical / Comparison / Indexing",
    "synopsis": "dl_gteIndex list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise greater than or equal to (>=) comparison and returns a new list of 0-based indices where true. For chained, e.g. a>=b AND b>=c, indices are where entire chain is true.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 0-based indices where the comparison is true."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists/values are not compatible for comparison (cannot be broadcast or compared)."
    ],
    "example": "set l1 [dl_create 5 2 8 1 9]\nset l2 [dl_create 3 2 8 0 10]\nset idx1 [dl_gteIndex $l1 $l2] ;# idx1 is [0 1 2 3]\nset idx2 [dl_gteIndex $l1 5]   ;# idx2 is [0 2 4]\n\nset l3 [dl_create 2 2 2]\n# Chained: (l1 >= l3) AND (l3 >= 2)\nset idx3 [dl_gteIndex $l1 $l3 2] ;# e.g. l1[0]=5,l3[0]=2 -> (5>=2 AND 2>=2) -> true, index 0",
    "see_also": ["dl_gte", "dl_gtIndex", "dl_ltIndex", "dl_lteIndex", "dl_eqIndex", "dl_noteqIndex"]
  },
  {
    "command": "dl_gt",
    "category": "Logical / Comparison",
    "synopsis": "dl_gt list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise greater than (>) comparison. If more than two arguments, checks chained comparison (e.g., a>b AND b>c). Returns a new list of 0s and 1s.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "Result contains 0 (false) or 1 (true) for each element-wise comparison."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists/values are not compatible for comparison (cannot be broadcast or compared)."
    ],
    "example": "set l1 [dl_create 5 2 8 1 9]\nset l2 [dl_create 3 7 8 0 2]\nset res1 [dl_gt $l1 $l2]   ;# res1 is [1 0 0 1 1]\nset res2 [dl_gt $l1 4]     ;# res2 is [1 0 1 0 1] (l1 compared to scalar 4)\n\nset l3 [dl_create 1 1 1]\n# For chained: (l1 > l3) AND (l3 > 0), assuming l3 broadcast against l1, and then scalar 0 against intermediate result\nset res3 [dl_gt $l1 $l3 0] ;# Example: l1[0]=5, l3[0]=1 -> (5>1 AND 1>0) -> 1. l1[1]=2, l3[1]=1 -> (2>1 AND 1>0) -> 1. l1[3]=1, l3[any]=1 -> (1>1 is false) -> 0",
    "see_also": ["dl_lt", "dl_gte", "dl_lte", "dl_eq", "dl_noteq", "dl_gtIndex"]
  },
  {
    "command": "dl_gtIndex",
    "category": "Logical / Comparison / Indexing",
    "synopsis": "dl_gtIndex list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise greater than (>) comparison and returns a new list of 0-based indices where true. For chained comparisons (e.g. a>b AND b>c), indices are where the entire chain is true.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 0-based indices where the comparison is true."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists/values are not compatible for comparison (cannot be broadcast or compared)."
    ],
    "example": "set l1 [dl_create 5 2 8 1 9]\nset l2 [dl_create 3 7 8 0 2]\nset idx1 [dl_gtIndex $l1 $l2] ;# idx1 is [0 3 4]\nset idx2 [dl_gtIndex $l1 4]   ;# idx2 is [0 2 4]\n\nset l3 [dl_create 1 1 1]\n# For chained: (l1 > l3) AND (l3 > 0)\nset idx3 [dl_gtIndex $l1 $l3 0] ;# Example: l1[0]=5,l3[0]=1 -> (5>1 AND 1>0) -> true, index 0. l1[1]=2,l3[1]=1 -> (2>1 AND 1>0) -> true, index 1. l1[3]=1,l3[any]=1 -> (1>1 is false) -> false",
    "see_also": ["dl_gt", "dl_ltIndex", "dl_gteIndex", "dl_lteIndex", "dl_eqIndex", "dl_noteqIndex"]
  },
  {
    "command": "dl_help",
    "category": "Introspection / Help",
    "synopsis": "dl_help [dl_command_name]",
    "brief": "Provides help information for dynamic list (dl_*) commands. If no command is specified, it may list all available dl_* commands or provide general help. Otherwise, it shows detailed help for the given dl_command_name.",
    "inputs": {
      "type": "string (optional)",
      "length": "0-1",
      "element_types": ["string (dl_command_name)"],
      "constraints": "If provided, 'dl_command_name' should be a valid dl_* command."
    },
    "returns": {
      "type": "string",
      "new_object": true,
      "brief": "Help text for the specified command, or a list/summary of all dl_* commands. The result might also be printed to standard output."
    },
    "side_effects": [
      "May print help information to standard output."
    ],
    "errors": [
      "TCL_ERROR if the specified 'dl_command_name' is provided but is not a valid or recognized dl_* command."
    ],
    "example": "dl_help              ;# Lists all dl_* commands or general help\ndl_help dl_create      ;# Shows help for the dl_create command\nset help_text [dl_help dl_add] ;# Stores help for dl_add in a variable",
    "see_also": ["dg_help"]
  },
  {
    "command": "dl_hist",
    "category": "Statistics / Histogramming",
    "synopsis": "dl_hist data_dynlist_name bins_dynlist_name",
    "brief": "Computes the histogram of a data list using specified bin edges. Returns a new list of counts.",
    "inputs": {
      "type": "varied",
      "length": 2,
      "element_types": ["string (data_dynlist_name)", "string (bins_dynlist_name)"],
      "constraints": [
        "'data_dynlist_name' must be a 1D numeric dynamic list.",
        "'bins_dynlist_name' must be a 1D numeric dynamic list of at least 2 monotonically increasing bin edges."
      ]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of counts, one for each bin defined by 'bins_dynlist_name'. Length is length(bins_dynlist_name) - 1."
    },
    "errors": [
      "TCL_ERROR if either dynlist is not found, not 1D, or not numeric.",
      "TCL_ERROR if 'bins_dynlist_name' has fewer than 2 elements.",
      "TCL_ERROR if bin edges in 'bins_dynlist_name' are not monotonically increasing.",
      "TCL_ERROR if memory allocation fails."
    ],
    "example": "set data [dl_flist 0.5 1.2 1.8 2.3 2.9 3.1 3.8 4.5]\nset bin_edges [dl_flist 0.0 1.0 2.0 3.0 4.0 5.0]\nset counts [dl_hist $data $bin_edges]\n# counts will be [1 2 2 2 1] corresponding to bins:\n# [0.0, 1.0): 1 (0.5)\n# [1.0, 2.0): 2 (1.2, 1.8)\n# [2.0, 3.0): 2 (2.3, 2.9)\n# [3.0, 4.0): 2 (3.1, 3.8)\n# [4.0, 5.0]: 1 (4.5) -- last bin includes upper edge\n\nset data2 [dl_ilist 1 1 1 2 2 3 4 4 4 4 5]\nset bins2 [dl_ilist 1 3 5 6] ;# Bins: [1,3), [3,5), [5,6]\nset counts2 [dl_hist $data2 $bins2]\n# counts2 will be [5 3 1]",
    "see_also": ["dl_bins", "dl_histBins", "dl_histLists", "dl_countOccurences", "dl_bincount"]
  },
  {
    "command": "dl_histBins",
    "category": "Statistics / Histogramming",
    "synopsis": "dl_histBins data_dynlist_name nbins [min_val] [max_val]",
    "brief": "Computes a histogram by automatically creating 'nbins' equal-width bins over a range (optionally specified by min_val, max_val, otherwise data min/max). Returns a new list of counts.",
    "inputs": {
      "type": "varied",
      "length": "2-4",
      "element_types": ["string (data_dynlist_name)", "integer (nbins)", "numeric (min_val, optional)", "numeric (max_val, optional)"],
      "constraints": [
        "'data_dynlist_name' must be a 1D numeric dynamic list.",
        "'nbins' must be a positive integer.",
        "If 'min_val' and 'max_val' are provided, 'min_val' must be less than 'max_val'.",
        "If 'min_val' and 'max_val' are not provided, the data list must not be empty."
      ]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 'nbins' counts corresponding to the automatically generated bins."
    },
    "errors": [
      "TCL_ERROR if 'data_dynlist_name' is not found, not 1D, or not numeric.",
      "TCL_ERROR if 'nbins' is not a positive integer.",
      "TCL_ERROR if 'min_val' or 'max_val' (if provided) are not numeric.",
      "TCL_ERROR if 'min_val' >= 'max_val' (if both provided).",
      "TCL_ERROR if 'data_dynlist_name' is empty and 'min_val'/'max_val' are not specified (cannot determine range).",
      "TCL_ERROR if memory allocation fails."
    ],
    "example": "set data [dl_flist 0.5 1.2 1.8 2.3 2.9 3.1 3.8 4.5 0.1 4.9]\n# Auto-range (approx 0.1 to 4.9)\nset counts1 [dl_histBins $data 5]\n# counts1 might be e.g. [2 2 2 2 2] if bins are roughly [0.1,1.06), [1.06,2.02), ... [3.94,4.9]\n\n# Specified range\nset counts2 [dl_histBins $data 4 0.0 4.0] ;# 4 bins over [0.0, 4.0]\n# Bins: [0,1), [1,2), [2,3), [3,4)\n# Expected counts2: [2 2 2 2] (for 0.1,0.5; 1.2,1.8; 2.3,2.9; 3.1,3.8; values 4.5, 4.9 are out of range)\n\nset data2 [dl_ilist 1 1 1 2 2 3 4 4 4 4 5 10 12]\nset counts3 [dl_histBins $data2 3 0 10] ;# 3 bins over [0,10)\n# Bins [0, 3.33), [3.33, 6.67), [6.67, 10)\n# counts3 would be [6 3 0] (for 1,1,1,2,2,3; 4,4,4,4,5; none)",
    "see_also": ["dl_hist", "dl_bins", "dl_histLists"]
  },
  {
    "command": "dl_histLists",
    "category": "Statistics / Histogramming",
    "synopsis": "dl_histLists data_list_of_lists_name bins_dynlist_name",
    "brief": "Computes histograms for multiple data lists (provided as a list of lists) using a common set of bin edges. Returns a list of count lists.",
    "inputs": {
      "type": "varied",
      "length": 2,
      "element_types": ["string (data_list_of_lists_name)", "string (bins_dynlist_name)"],
      "constraints": [
        "'data_list_of_lists_name' must be a dynamic list where each element is a 1D numeric dynamic list.",
        "'bins_dynlist_name' must be a 1D numeric dynamic list of at least 2 monotonically increasing bin edges."
      ]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "list (of integer lists)",
      "brief": "A list of lists. Each sublist contains histogram counts (integers) corresponding to a dataset in 'data_list_of_lists_name'."
    },
    "errors": [
      "TCL_ERROR if either dynlist is not found.",
      "TCL_ERROR if 'data_list_of_lists_name' is not a list of 1D numeric lists.",
      "TCL_ERROR if 'bins_dynlist_name' is not 1D numeric, has fewer than 2 elements, or its edges are not monotonically increasing.",
      "TCL_ERROR if memory allocation fails."
    ],
    "example": "set dataset1 [dl_flist 0.5 1.2 1.8 2.3]\nset dataset2 [dl_flist 1.1 2.2 3.3 4.4 0.9]\nset all_data [dl_llist $dataset1 $dataset2]\n\nset common_bins [dl_flist 0.0 1.0 2.0 3.0 4.0 5.0]\nset hist_results [dl_histLists $all_data $common_bins]\n\n# hist_results will be a list of two lists:\n# For dataset1 ([0.5 1.2 1.8 2.3]): counts might be [1 2 1 0 0]\n# For dataset2 ([1.1 2.2 3.3 4.4 0.9]): counts might be [1 1 1 1 1]\n\n# set first_hist [dl_first $hist_results] ;# to get the counts for dataset1\n# set second_hist [dl_get $hist_results 1] ;# to get the counts for dataset2",
    "see_also": ["dl_hist", "dl_bins", "dl_histBins", "dl_bincountLists"]
  },
  {
    "command": "dl_hmean",
    "category": "Statistics / Reduction",
    "synopsis": "dl_hmean dynlist_name",
    "brief": "Computes the harmonic mean of the elements in a numeric dynamic list. All elements must be positive.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["string (name of a 1D numeric dynamic list)"],
      "constraints": [
        "The dynamic list must be 1D and numeric.",
        "All elements in the list must be positive (greater than zero)."
      ]
    },
    "returns": {
      "type": "float",
      "new_object": false,
      "brief": "A single float value representing the harmonic mean of the list elements."
    },
    "errors": [
      "TCL_ERROR if 'dynlist_name' is not found, not 1D, or not numeric.",
      "TCL_ERROR if the list is empty.",
      "TCL_ERROR if any element in the list is zero or negative."
    ],
    "example": "set data1 [dl_flist 1.0 2.0 4.0]\nset hmean1 [dl_hmean $data1] ;# H = 3 / (1/1 + 1/2 + 1/4) = 3 / (1 + 0.5 + 0.25) = 3 / 1.75 = ~1.714\n\nset data2 [dl_ilist 2 3 6]\nset hmean2 [dl_hmean $data2] ;# H = 3 / (1/2 + 1/3 + 1/6) = 3 / (0.5 + 0.333 + 0.166) = 3 / 1 = 3.0\n\n# set data_with_zero [dl_flist 1.0 0.0 2.0]\n# dl_hmean $data_with_zero ;# This would cause an error.",
    "see_also": ["dl_mean", "dl_bmean", "dl_geomean", "dl_sum", "dl_std"]
  },
  {
    "command": "dl_hstd",
    "category": "Statistics / Reduction",
    "synopsis": "dl_hstd dynlist_name_or_lol_name",
    "brief": "Computes the standard deviation horizontally. If input is a list of lists, computes std dev for each sublist (row) returning a list of std devs. If input is a 1D list, computes its std dev and returns it in a single-element list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["string (name of a 1D numeric list or a list of 1D numeric lists)"],
      "constraints": [
        "Input must be a 1D numeric list or a list of 1D numeric lists (LoL).",
        "Each numeric list/sublist for which std dev is computed must contain at least 2 elements (for sample std dev) and be numeric."
      ]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float (or list of floats if input is LoL)",
      "brief": "A new list. If input was LoL, it's a list of standard deviation values (float), one for each sublist. If input was a 1D list, it's a single-element list containing its standard deviation."
    },
    "errors": [
      "TCL_ERROR if 'dynlist_name_or_lol_name' is not found or is of an unsuitable type.",
      "TCL_ERROR if any sublist (in LoL case) or the list itself (in 1D case) is not numeric, is empty, or has insufficient elements for std dev calculation."
    ],
    "example": "set data1 [dl_flist 1.0 2.0 3.0 4.0 5.0]\nset hstd1 [dl_hstd $data1] ;# hstd1 is a list like [1.5811] (std dev of data1)\n\nset sublistA [dl_ilist 1 2 3]\nset sublistB [dl_ilist 10 20 30 40]\nset lol_data [dl_llist $sublistA $sublistB]\nset hstd_lol [dl_hstd $lol_data]\n# hstd_lol is a list of std devs: e.g., [1.0 (std of sublistA), 12.91 (std of sublistB)]\n\n# Assuming it is similar to dl_bstds",
    "see_also": ["dl_std", "dl_bstds", "dl_bmean", "dl_hvar", "dl_var"]
  },
  {
    "command": "dl_hvar",
    "category": "Statistics / Reduction",
    "synopsis": "dl_hvar dynlist_name_or_lol_name",
    "brief": "Computes the variance horizontally. If input is a list of lists, computes variance for each sublist (row) returning a list of variances. If input is a 1D list, computes its variance and returns it in a single-element list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["string (name of a 1D numeric list or a list of 1D numeric lists)"],
      "constraints": [
        "Input must be a 1D numeric list or a list of 1D numeric lists (LoL).",
        "Each numeric list/sublist for which variance is computed must contain at least 2 elements (for sample variance) and be numeric."
      ]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float (or list of floats if input is LoL)",
      "brief": "A new list. If input was LoL, it's a list of variance values (float), one for each sublist. If input was a 1D list, it's a single-element list containing its variance."
    },
    "errors": [
      "TCL_ERROR if 'dynlist_name_or_lol_name' is not found or is of an unsuitable type.",
      "TCL_ERROR if any sublist (in LoL case) or the list itself (in 1D case) is not numeric, is empty, or has insufficient elements for variance calculation."
    ],
    "example": "set data1 [dl_flist 1.0 2.0 3.0 4.0 5.0]\nset hvar1 [dl_hvar $data1] ;# hvar1 is a list like [2.5] (variance of data1, approx (1.5811)^2)\n\nset sublistA [dl_ilist 1 2 3]\nset sublistB [dl_ilist 10 20 30 40]\nset lol_data [dl_llist $sublistA $sublistB]\nset hvar_lol [dl_hvar $lol_data]\n# hvar_lol is a list of variances: e.g., [1.0 (var of sublistA), 166.66 (var of sublistB, approx (12.91)^2)]\n\n# Assuming it is similar to dl_bvar or a row-wise dl_var",
    "see_also": ["dl_var", "dl_bvar", "dl_bstd", "dl_hstd", "dl_std"]
  },
  {
    "command": "dl_idiff",
    "category": "Arithmetic / Data Analysis",
    "synopsis": "dl_idiff dynlist_name [lag]",
    "brief": "Computes the element-wise integer difference between lagged elements of an integer dynamic list (list[i+lag] - list[i]). Returns a new integer list.",
    "inputs": {
      "type": "varied",
      "length": "1-2",
      "element_types": ["string (dynlist_name)", "integer (lag, optional)"],
      "constraints": [
        "Input list must be a 1D integer (or long) dynamic list.",
        "'lag' must be a positive integer, defaults to 1 if omitted.",
        "List length must be greater than 'lag'."
      ]
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "integer (or long)",
      "brief": "The resulting integer list will be shorter than the input list by 'lag' elements."
    },
    "errors": [
      "TCL_ERROR if 'dynlist_name' is not found, not a 1D integer/long list.",
      "TCL_ERROR if 'lag' (if provided) is not a positive integer.",
      "TCL_ERROR if list length is not greater than 'lag'."
    ],
    "example": "set myList [dl_ilist 1 3 6 10 15]\nset idiff1 [dl_idiff $myList]      ;# lag=1, idiff1 is [2 3 4 5]\nset idiff2 [dl_idiff $myList 2]  ;# lag=2, idiff2 is [5 7 9]\n\nset anotherList [dl_create 10 8 5 0 -7]\nset idiff_neg [dl_idiff $anotherList] ;# idiff_neg is [-2 -3 -5 -7]",
    "see_also": ["dl_diff", "dl_sub", "dl_cumsum"]
  },
  {
    "command": "dl_ilist",
    "category": "Creation",
    "synopsis": "dl_ilist [value1 value2 ... | {value_list} | dynlist_name1 dynlist_name2 ...]",
    "brief": "Creates a new dynamic list of type integer (specifically long). Initializes with optional values, converting them to integers.",
    "inputs": {
      "type": "varied (integer values, Tcl list, or dynlist names)",
      "length": "0+",
      "element_types": ["integer_convertible (value_to_convert_to_int)", "Tcl list of integer_convertible values", "string (dynlist_name_of_convertible_list)"],
      "constraints": "All inputs will be converted to integer (long). Non-integer numeric inputs (e.g. floats) will be truncated. Non-numeric string inputs will cause an error unless they represent valid integers."
    },
    "returns": {
      "type": "string (name of new integer DynList)",
      "new_object": true,
      "element_type": "integer (long)"
    },
    "errors": [
      "TCL_ERROR if any input value cannot be converted to an integer (e.g., non-numeric string).",
      "TCL_ERROR if a named dynlist argument is not found or contains data that cannot be converted to integer."
    ],
    "example": "set intList1 [dl_ilist 10 20 30]        ;# intList1 is [10 20 30]\nset intList2 [dl_ilist {100 -200 300}]   ;# intList2 is [100 -200 300]\nset floatList [dl_flist 1.2 2.7 3.0]\nset intList3 [dl_ilist $floatList 40]   ;# intList3 is [1 2 3 40] (floats truncated)\nset emptyInts [dl_ilist]                 ;# Creates an empty integer list\n# set badList [dl_ilist hello 10] ;# This would error",
    "see_also": ["dl_create", "dl_flist", "dl_slist", "dl_clist", "dl_llist", "dl_int"]
  },
  {
    "command": "dl_incr",
    "category": "Arithmetic / Manipulation",
    "synopsis": "dl_incr dynlist_name index [increment_value]",
    "brief": "Increments the numeric element at a specified index within a dynamic list. Modifies the list in-place.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["string (dynlist_name)", "integer (index)", "numeric (increment_value, optional)"],
      "constraints": [
        "'dynlist_name' must refer to an existing numeric dynamic list (integer or float).",
        "'index' must be a 0-based integer within the bounds of the list.",
        "'increment_value' defaults to 1 if not provided. It must be numeric and compatible with the list's type."
      ]
    },
    "returns": {
      "type": "numeric",
      "new_object": false,
      "brief": "The new value of the element after incrementing. Type matches the list's element type."
    },
    "side_effects": [
      "The element at the specified 'index' in 'dynlist_name' is modified."
    ],
    "errors": [
      "TCL_ERROR if 'dynlist_name' is not found or is not a numeric list.",
      "TCL_ERROR if 'index' is not a valid integer or is out of bounds.",
      "TCL_ERROR if 'increment_value' (if provided) is not numeric or causes an overflow/conversion error with the list's element type."
    ],
    "example": "set myInts [dl_ilist 10 20 30]\ndl_incr $myInts 1          ;# myInts becomes [10 21 30], returns 21\ndl_incr $myInts 0 5        ;# myInts becomes [15 21 30], returns 15\ndl_incr $myInts 2 -10      ;# myInts becomes [15 21 20], returns 20\n\nset myFloats [dl_flist 1.0 2.5 3.0]\ndl_incr $myFloats 1 0.5    ;# myFloats becomes [1.0 3.0 3.0], returns 3.0",
    "see_also": ["dl_add", "dl_put", "dl_set", "dl_increment"]
  },
  {
    "command": "dl_increment",
    "category": "Arithmetic / Manipulation",
    "synopsis": "dl_increment dynlist_name [increment_value]",
    "brief": "Increments all elements of a numeric dynamic list by a specified value (default 1). Modifies the list in-place.",
    "inputs": {
      "type": "varied",
      "length": "1-2",
      "element_types": ["string (dynlist_name)", "numeric (increment_value, optional)"],
      "constraints": [
        "'dynlist_name' must refer to an existing numeric dynamic list (integer or float).",
        "'increment_value' defaults to 1 if not provided. It must be numeric."
      ]
    },
    "returns": {
      "type": "string",
      "new_object": false,
      "brief": "The name of the modified dynamic list."
    },
    "side_effects": [
      "All elements in 'dynlist_name' are incremented by 'increment_value'."
    ],
    "errors": [
      "TCL_ERROR if 'dynlist_name' is not found or is not a numeric list.",
      "TCL_ERROR if 'increment_value' (if provided) is not numeric or causes an overflow/conversion error with the list's element type."
    ],
    "example": "set myInts [dl_ilist 10 20 30]\ndl_increment $myInts       ;# myInts becomes [11 21 31]\nputs $myInts ;# To verify, e.g. %listN\n\ndl_increment $myInts 5     ;# myInts becomes [16 26 36]\nputs $myInts\n\nset myFloats [dl_flist 1.0 2.5]\ndl_increment $myFloats -0.5 ;# myFloats becomes [0.5 2.0]\nputs $myFloats",
    "see_also": ["dl_incr", "dl_add", "dl_sub"]
  },
  {
    "command": "dl_index",
    "category": "Accessing Elements",
    "synopsis": "dl_index dynlist_name index1 [index2 ...]",
    "brief": "Retrieves an element or sublist from a dynamic list using one or more 0-based indices. Returns the element value or the name of the sublist. Alias for/identical to dl_get.",
    "inputs": {
      "type": "varied",
      "length": "2+",
      "element_types": ["string (dynlist_name)", "integer (index1)", "integer (index2, optional)", "..."],
      "constraints": "'dynlist_name' must be an existing list. Indices must be 0-based integers and within bounds for each list level."
    },
    "returns": {
      "type": "any_or_string (dynlist_name)",
      "new_object": false,
      "brief": "The value of the element at the specified index(es). If the element is a sublist, its name (a string) is returned."
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found.",
      "TCL_ERROR if any index is not an integer or is out of bounds.",
      "TCL_ERROR if too many indices are provided for the list's depth."
    ],
    "example": "set myList [dl_create apple banana cherry]\nset item1 [dl_index $myList 1]       ;# item1 is \"banana\"\n\nset myNums [dl_ilist 10 20 30 40]\nset num_val [dl_index $myNums 0]    ;# num_val is 10\n\nset sub1 [dl_create 1 2]\nset sub2 [dl_slist x y z]\nset lol [dl_llist $sub1 $sub2]\nset sublist_name [dl_index $lol 0]   ;# sublist_name is the name of sub1 (e.g., %listN)\nset deep_item [dl_index $lol 1 2]    ;# deep_item is \"z\" (from sub2 at index 1 of lol, then index 2 of sub2)",
    "see_also": ["dl_get", "dl_first", "dl_last", "dl_put", "dl_set", "dl_sublist"]
  },
  {
    "command": "dl_index_list",
    "category": "Manipulation / Selection",
    "synopsis": "dl_index_list source_dynlist_name indices_dynlist_name",
    "brief": "Creates a new list by selecting elements from 'source_dynlist' at positions specified in 'indices_dynlist'. Similar to dl_choose.",
    "inputs": {
      "type": "varied",
      "length": "2",
      "element_types": ["string (source_dynlist_name)", "string (indices_dynlist_name)"],
      "constraints": [
        "'source_dynlist_name' must be an existing dynamic list of any type.",
        "'indices_dynlist_name' must be an existing 1D dynamic list of integers (0-based indices).",
        "All indices in 'indices_dynlist_name' must be valid for 'source_dynlist_name'."
      ]
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "Same as 'source_dynlist_name'."
    },
    "errors": [
      "TCL_ERROR if either 'source_dynlist_name' or 'indices_dynlist_name' is not found.",
      "TCL_ERROR if 'indices_dynlist_name' is not a 1D integer list.",
      "TCL_ERROR if any index in 'indices_dynlist_name' is out of bounds for 'source_dynlist_name'."
    ],
    "example": "set source [dl_slist a b c d e f]\nset indices [dl_ilist 0 2 4 1 1]\nset result [dl_index_list $source $indices] ;# result will be a new list: [a c e b b]\n\nset nums [dl_ilist 10 20 30 40 50]\nset idx [dl_ilist 3 0 3]\nset selected_nums [dl_index_list $nums $idx] ;# selected_nums is [40 10 40]",
    "see_also": ["dl_choose", "dl_select", "dl_get", "dl_permute", "dl_sublist"]
  },
  {
    "command": "dl_insert",
    "category": "Manipulation",
    "synopsis": "dl_insert dynlist_name index value1 [value2 ... | dynlist_to_insert1 ...]",
    "brief": "Inserts one or more values (or elements from other dynlists) into a dynamic list at a specified index. Modifies the list in-place.",
    "inputs": {
      "type": "varied",
      "length": "3+",
      "element_types": ["string (dynlist_name)", "integer (index)", "any (value_to_insert_or_dynlist_name)", "..."],
      "constraints": [
        "'dynlist_name' must be an existing dynamic list.",
        "'index' must be a 0-based integer from 0 to length(dynlist_name) inclusive.",
        "Values to insert must be compatible with the data type of 'dynlist_name'.",
        "If a value is a dynlist name, its elements are inserted; these must also be compatible."
      ]
    },
    "returns": {
      "type": "string",
      "new_object": false,
      "brief": "The name of the modified dynamic list."
    },
    "side_effects": [
      "The 'dynlist_name' is modified by inserting the new value(s) at the specified 'index'."
    ],
    "errors": [
      "TCL_ERROR if 'dynlist_name' is not found.",
      "TCL_ERROR if 'index' is not a valid integer or is out of bounds (0 to length).",
      "TCL_ERROR if a value to insert cannot be converted to the dynlist's datatype (e.g., inserting a string into an integer list, unless it's a list of lists that can hold it).",
      "TCL_ERROR if a dynlist name provided for insertion is not found or its elements are incompatible."
    ],
    "example": "set myList [dl_create a d e]\ndl_insert $myList 1 b c        ;# myList is now [a b c d e]\n\nset myNums [dl_ilist 10 40]\ndl_insert $myNums 1 20 30      ;# myNums is now [10 20 30 40]\ndl_insert $myNums 0 0          ;# myNums is now [0 10 20 30 40]\ndl_insert $myNums 5 50         ;# myNums is now [0 10 20 30 40 50] (insert at end)\n\nset listToIns [dl_slist x y]\ndl_insert $myList 1 $listToIns ;# If myList can hold other lists, or if elements of listToIns are inserted individually (behavior depends on implementation for LoL vs flat lists)",
    "see_also": ["dl_append", "dl_prepend", "dl_replace", "dl_put", "dl_set", "dl_spliceAfter", "dl_spliceBefore"]
  },
  {
    "command": "dl_int",
    "category": "Conversion / Creation",
    "synopsis": "dl_int source_data [output_var_name]",
    "brief": "Converts elements of 'source_data' (dynlist, Tcl list, or literals) to integer type, returning a new integer dynlist. Optionally stores new list's name in 'output_var_name'.",
    "inputs": {
      "type": "varied",
      "length": "1-2",
      "element_types": ["string_or_list_or_values (source_data)", "string (output_var_name, optional)"],
      "constraints": [
        "'source_data' can be a dynlist name, a Tcl list of convertible values, or individual convertible literal values.",
        "All inputs are converted to integer (long). Floats are truncated. Non-numeric strings (that don't represent integers) or complex list structures will cause errors."
      ]
    },
    "returns": {
      "type": "string (name of new integer DynList)",
      "new_object": true,
      "element_type": "integer (long)"
    },
    "side_effects": [
      "If 'output_var_name' is provided, the Tcl variable by that name is set to the name of the new integer dynlist."
    ],
    "errors": [
      "TCL_ERROR if 'source_data' (if a dynlist name) is not found.",
      "TCL_ERROR if 'source_data' contains values that cannot be converted to integer (e.g., non-numeric strings, lists of lists).",
      "TCL_ERROR if 'output_var_name' (if used) is invalid."
    ],
    "example": "set floatList [dl_flist 1.2 2.7 3.0 -0.8]\nset intList1 [dl_int $floatList]            ;# intList1 is [1 2 3 0] (floats truncated)\n\ndl_int {5 6.6 \"7\" \"-8\"} newIntListName     ;# newIntListName holds name of [5 6 7 -8]\n# puts [dl_dump $newIntListName]              ;# To verify\n\nset intList2 [dl_int 100 101.5 \"102\"]        ;# intList2 is [100 101 102]\n\n# set badConv [dl_int \"hello\"] ;# This would error",
    "see_also": ["dl_ilist", "dl_float", "dl_char", "dl_stringmatch", "dl_convert"]
  },
  {
    "command": "dl_interleave",
    "category": "Manipulation / Restructuring",
    "synopsis": "dl_interleave dynlist1_name dynlist2_name [dynlist3_name ...]",
    "brief": "Creates a new list by interleaving elements from two or more input lists. Elements are taken sequentially from each list in turn. If lists have unequal lengths, remaining elements from longer lists are appended afterwards.",
    "inputs": {
      "type": "strings (dynlist_names)",
      "length": "2+",
      "element_types": ["string (name of a dynlist)"],
      "constraints": "All input dynamic lists must exist. They should ideally be of compatible types; if not, type promotion rules will apply (e.g., int + float -> float)."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "any (common promoted type of input lists)"
    },
    "errors": [
      "TCL_ERROR if fewer than two dynlist names are provided.",
      "TCL_ERROR if any specified dynlist_name is not found.",
      "TCL_ERROR if input lists cannot be combined due to incompatible types or memory allocation failure."
    ],
    "example": "set listA [dl_ilist 1 2 3]\nset listB [dl_slist a b c d]\nset listC [dl_flist 10.1 20.2]\n\nset interleaved1 [dl_interleave $listA $listB]\n# interleaved1 might be [1 a 2 b 3 c d] (assuming int promotes to string or uses string representation)\n\nset interleaved2 [dl_interleave $listA $listC]\n# interleaved2 might be [1.0 10.1 2.0 20.2 3.0] (int promoted to float)\n\nset listX [dl_ilist 100 200]\nset listY [dl_ilist 300 400 500]\nset listZ [dl_ilist 600]\nset interleaved3 [dl_interleave $listX $listY $listZ]\n# interleaved3: [100 300 600 200 400 500] (100,300,600 from first picks, then 200,400, then 500 appended)",
    "see_also": ["dl_concat", "dl_combine", "dl_append", "dl_zip"]
  },
  {
    "command": "dl_irand",
    "category": "Creation / Random",
    "synopsis": "dl_irand count min_val max_val [seed]",
    "brief": "Creates a new dynamic list of 'count' random integers, each uniformly distributed in the range [min_val, max_val] inclusive. An optional seed can be provided.",
    "inputs": {
      "type": "varied",
      "length": "3-4",
      "element_types": ["integer (count)", "integer (min_val)", "integer (max_val)", "integer (seed, optional)"],
      "constraints": [
        "'count' must be a non-negative integer.",
        "'min_val' and 'max_val' must be integers.",
        "'min_val' must not be greater than 'max_val'.",
        "If 'seed' is provided, it must be an integer."
      ]
    },
    "returns": {
      "type": "string (name of new integer DynList)",
      "new_object": true,
      "element_type": "integer (long)"
    },
    "errors": [
      "TCL_ERROR if 'count' is negative.",
      "TCL_ERROR if 'min_val' or 'max_val' are not integers.",
      "TCL_ERROR if 'min_val' > 'max_val'.",
      "TCL_ERROR if 'seed' (if provided) is not a valid integer.",
      "TCL_ERROR for memory allocation failure."
    ],
    "example": "set randInts1 [dl_irand 10 1 6]    ;# Creates a list of 10 random integers between 1 and 6 (like dice rolls)\n# puts [dl_dump $randInts1]\n\nset randInts2 [dl_irand 5 -100 100] ;# 5 random integers between -100 and 100\n# puts [dl_dump $randInts2]\n\nset seed_val 12345\nset randInts_s1 [dl_irand 3 0 1 $seed_val]\nset randInts_s2 [dl_irand 3 0 1 $seed_val] ;# randInts_s1 and randInts_s2 should be identical",
    "see_also": ["dl_urand", "dl_zrand", "dl_randchoose", "dl_randfill", "dl_shuffle", "dl_create"]
  },
  {
    "command": "dl_isMatrix",
    "category": "Introspection / Type Checking",
    "synopsis": "dl_isMatrix dynlist_name",
    "brief": "Checks if the given dynamic list qualifies as a matrix (a list of lists where all sublists have the same length and data type).",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["string (name of an existing dynamic list)"]
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "Returns 1 if the list is a valid matrix, 0 otherwise."
    },
    "errors": [
      "TCL_ERROR if 'dynlist_name' is not found."
    ],
    "example": "set listA [dl_ilist 1 2 3]\nset listB [dl_ilist 4 5 6]\nset matrix1 [dl_llist $listA $listB]\nset is_mat1 [dl_isMatrix $matrix1]   ;# is_mat1 is 1\n\nset listC [dl_ilist 7 8] ;# Different length\nset not_matrix1 [dl_llist $listA $listC]\nset is_mat2 [dl_isMatrix $not_matrix1] ;# is_mat2 is 0\n\nset listD [dl_flist 1.0 2.0 3.0] ;# Different type (assuming listA is int)\nset not_matrix2 [dl_llist $listA $listD]\n# is_mat3 behavior depends on how strictly types are checked for matrix uniformity.\n# If sublist types must be identical, is_mat3 is 0.\n# If they only need to be compatible for a common matrix type (e.g. all numeric), could be 1.\n# Assuming strict type identity for sublists for this definition.\nset is_mat3 [dl_isMatrix $not_matrix2] ;# Likely 0 if types must be identical (e.g. DF_LONG vs DF_FLOAT)\n\nset simple_list [dl_create 1 2 3]\nset is_mat4 [dl_isMatrix $simple_list] ;# is_mat4 is 0 (not a list of lists)",
    "see_also": ["dl_datatype", "dl_depth", "dl_length", "dl_lengths", "dl_llist"]
  },
  {
    "command": "dl_last",
    "category": "Accessing Elements",
    "synopsis": "dl_last dynlist_name",
    "brief": "Returns the last element of a dynamic list. If the list is a list of lists, it returns the name of the last sublist.",
    "inputs": {
      "type": "string",
      "length": 1,
      "element_types": ["string (dynlist_name)"],
      "constraints": "The dynamic list must not be empty."
    },
    "returns": {
      "type": "any_or_string (dynlist_name)",
      "new_object": false,
      "brief": "The last element of the list, or the name of the last sublist if it's a list of lists."
    },
    "errors": [
      "TCL_ERROR if dynlist_name is not found.",
      "TCL_ERROR if the list is empty.",
      "TCL_ERROR if the wrong number of arguments is provided."
    ],
    "example": "set myList [dl_create apple banana cherry]\nset last_item [dl_last $myList]   ;# last_item is \"cherry\"\n\nset myNums [dl_ilist 10 20 30]\nset last_num [dl_last $myNums]     ;# last_num is 30\n\nset sub1 [dl_create 1 2]\nset sub2 [dl_create 3 4]\nset lol [dl_llist $sub1 $sub2]\nset last_sublist_name [dl_last $lol] ;# last_sublist_name is the name of sub2 (e.g., %listN)",
    "see_also": ["dl_first", "dl_get", "dl_index", "dl_pickone"]
  },
  {
    "command": "dl_lastPos",
    "category": "Searching / Indexing",
    "synopsis": "dl_lastPos dynlist_name value_to_find [end_index]",
    "brief": "Returns the 0-based index of the last occurrence of a specific 'value_to_find' in a dynamic list. Optionally searches only up to 'end_index'. Returns -1 if not found.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["string (dynlist_name)", "any (value_to_find)", "integer (end_index, optional)"],
      "constraints": [
        "'dynlist_name' must refer to an existing dynamic list.",
        "'value_to_find' must be a literal value comparable with the list elements.",
        "If 'end_index' is provided, it must be a valid 0-based integer index within the list bounds; the search is performed within the sublist from index 0 up to 'end_index' inclusive."
      ]
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "0-based index of the last occurrence of the value, or -1 if not found within the search range."
    },
    "errors": [
      "TCL_ERROR if 'dynlist_name' is not found.",
      "TCL_ERROR if 'value_to_find' cannot be compared with list elements.",
      "TCL_ERROR if 'end_index' (if provided) is not a valid integer or is out of the list's bounds."
    ],
    "example": "set myList [dl_create a b c a b d a b c e]\nset pos1 [dl_lastPos $myList a]          ;# pos1 is 6 (last 'a')\nset pos2 [dl_lastPos $myList a 3]        ;# pos2 is 3 (last 'a' in sublist [a b c a])\nset pos3 [dl_lastPos $myList c]          ;# pos3 is 8\nset pos4 [dl_lastPos $myList x]          ;# pos4 is -1\n\nset myNums [dl_ilist 10 20 10 30 10 25]\nset num_pos1 [dl_lastPos $myNums 10]     ;# num_pos1 is 4\nset num_pos2 [dl_lastPos $myNums 10 2]   ;# num_pos2 is 2 (last 10 in [10 20 10])",
    "see_also": ["dl_firstPos", "dl_find", "dl_findAll", "dl_index"]
  },
  {
    "command": "dl_last_index_list",
    "category": "Searching / Indexing",
    "synopsis": "dl_last_index_list source_dynlist_name search_values_dynlist_name [end_index]",
    "brief": "Finds the 0-based index of the last element in 'source_dynlist' (optionally up to 'end_index') that matches any value present in 'search_values_dynlist'. Returns -1 if no match found.",
    "inputs": {
      "type": "varied",
      "length": "2-3",
      "element_types": ["string (source_dynlist_name)", "string (search_values_dynlist_name)", "integer (end_index, optional)"],
      "constraints": [
        "Both inputs must be valid dynlist names.",
        "Elements in 'source_dynlist' and 'search_values_dynlist' must be comparable.",
        "If 'end_index' is provided, it must be a valid 0-based integer index within the bounds of 'source_dynlist'; the search considers elements from index 0 up to 'end_index' inclusive."
      ]
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "0-based index in source_dynlist of the last match within the search range, or -1."
    },
    "errors": [
      "TCL_ERROR if 'source_dynlist_name' or 'search_values_dynlist_name' not found.",
      "TCL_ERROR if 'end_index' (if provided) is not a valid integer or is out of bounds for 'source_dynlist'.",
      "TCL_ERROR if elements are not comparable between lists."
    ],
    "example": "set sourceList [dl_slist a b c d e f c a g]\nset searchFor1 [dl_slist x c e z]\nset last_idx1 [dl_last_index_list $sourceList $searchFor1]    ;# last_idx1 is 6 (due to 'c' at index 6)\nset last_idx2 [dl_last_index_list $sourceList $searchFor1 5]  ;# last_idx2 is 4 (due to 'e' at index 4, searching in [a b c d e f])\n\nset searchFor2 [dl_slist b g]\nset last_idx3 [dl_last_index_list $sourceList $searchFor2]    ;# last_idx3 is 8 (due to 'g' at index 8)\n\nset noMatchSearch [dl_slist k l m]\nset no_match_idx [dl_last_index_list $sourceList $noMatchSearch] ;# no_match_idx is -1",
    "see_also": ["dl_first_index_list", "dl_lastPos", "dl_find", "dl_oneof"]
  },
  {
    "command": "dl_length",
    "category": "Introspection",
    "synopsis": "dl_length dynlist_name",
    "brief": "Returns the number of elements in the top level of a dynamic list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["The name of an existing dynamic list."]
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "The number of elements in the list. If it's a list of lists, this is the count of sublists."
    },
    "errors": [
      "TCL_ERROR if 'dynlist_name' does not refer to an existing dynamic list.",
      "TCL_ERROR if the wrong number of arguments is provided."
    ],
    "example": "set simpleList [dl_create 10 20 30 40]\nset len1 [dl_length $simpleList]  ;# len1 is 4\n\nset sub1 [dl_create a b]\nset sub2 [dl_create c d e]\nset listOfLists [dl_llist $sub1 $sub2]\nset len2 [dl_length $listOfLists] ;# len2 is 2 (it contains two sublists)\n\nset emptyList [dl_create]\nset len3 [dl_length $emptyList]   ;# len3 is 0",
    "see_also": ["dl_llength", "dl_lengths", "dl_depth", "dl_datatype", "dl_size"]
  },
  {
    "command": "dl_lengths",
    "category": "Introspection / List of Lists",
    "synopsis": "dl_lengths list_of_lists_name",
    "brief": "Returns a new list containing the lengths of each sublist within a list of lists.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["The name of an existing dynamic list, which must be a list of lists (e.g., created by dl_llist)."]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A new list where each element is the length of the corresponding sublist in the input list."
    },
    "errors": [
      "TCL_ERROR if 'list_of_lists_name' does not refer to an existing dynamic list.",
      "TCL_ERROR if the input list is not a list of lists (type DF_LIST).",
      "TCL_ERROR if the wrong number of arguments is provided."
    ],
    "example": "set subA [dl_create 1 2 3]\nset subB [dl_slist x y]\nset subC [dl_create 10]\nset subD [dl_create] ;# Empty sublist\nset lol [dl_llist $subA $subB $subC $subD]\nset lengthsList [dl_lengths $lol] ;# lengthsList will be an integer list: [3 2 1 0]\n\nset simpleList [dl_create a b c]\n# dl_lengths $simpleList ;# This would likely cause an error as simpleList is not a list of lists.",
    "see_also": ["dl_length", "dl_llength", "dl_depth", "dl_isMatrix"]
  },
  {
    "command": "dl_lgamma",
    "category": "Arithmetic / Special Functions",
    "synopsis": "dl_lgamma dynlist_name | dl_lgamma number",
    "brief": "Computes the element-wise natural logarithm of the absolute value of the Gamma function, log(|(x)|). Returns a new list of floats.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"],
      "constraints": "Input elements must be numeric. The function is undefined for non-positive integers (0, -1, -2, ...) where the Gamma function has poles."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float"
    },
    "errors": [
      "TCL_ERROR if input list/number is not found or not numeric.",
      "TCL_ERROR if any input element is a non-positive integer (0, -1, -2, ...).",
      "TCL_ERROR for general mathematical errors (e.g., convergence issues, out of range for internal calculations)."
    ],
    "example": "set values [dl_create 0.5 1 2 3.5 -1.5]\n# (0.5) = sqrt(pi) approx 1.772, log(1.772) approx 0.572\n# (1) = 0! = 1, log(1) = 0\n# (2) = 1! = 1, log(1) = 0\n# (3.5) = 2.5 * 1.5 * 0.5 * (0.5) approx 3.323, log(3.323) approx 1.201\n# (-1.5) = (0.5) / (-1.5 * -0.5) approx 1.772 / 0.75 approx 2.363, log(2.363) approx 0.860\nset lgamma_values [dl_lgamma $values] \n# lgamma_values approx [0.57232 0.0 0.0 1.20097 0.86006]\n\ndl_lgamma 5 ;# (5) = 4! = 24, log(24) approx 3.178\n# dl_lgamma 0 ;# Would cause an error\n# dl_lgamma -2 ;# Would cause an error",
    "see_also": ["dl_exp", "dl_log", "dl_fact (if exists, for factorial which is related to Gamma)"]
  },
  {
    "command": "dl_llength",
    "category": "Introspection",
    "synopsis": "dl_llength dynlist_name",
    "brief": "Returns the number of elements in the top level of a dynamic list. Functionally equivalent to dl_length.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["The name of an existing dynamic list."]
    },
    "returns": {
      "type": "integer",
      "new_object": false,
      "brief": "The number of elements in the list. If it's a list of lists, this is the count of sublists. Same as 'dl_length'."
    },
    "errors": [
      "TCL_ERROR if 'dynlist_name' does not refer to an existing dynamic list.",
      "TCL_ERROR if the wrong number of arguments is provided."
    ],
    "example": "set simpleList [dl_create 10 20 30 40]\nset llen1 [dl_llength $simpleList]  ;# llen1 is 4\n\nset sub1 [dl_create a b]\nset sub2 [dl_create c d e]\nset listOfLists [dl_llist $sub1 $sub2]\nset llen2 [dl_llength $listOfLists] ;# llen2 is 2 (it contains two sublists)\n\nset emptyList [dl_create]\nset llen3 [dl_llength $emptyList]   ;# llen3 is 0\n\n# Functionally identical to dl_length in these cases.",
    "see_also": ["dl_length", "dl_lengths", "dl_depth", "Tcl built-in llength"]
  },
  {
    "command": "dl_llist",
    "category": "Creation / List of Lists",
    "synopsis": "dl_llist [dynlist_name1 dynlist_name2 ... | {dynlist_name_Tcl_list}]",
    "brief": "Creates a new dynamic list specifically designed to hold other dynamic lists as its elements (a list of lists). Optionally initializes it with existing dynamic lists.",
    "inputs": {
      "type": "varied (dynlist names or Tcl list of dynlist names)",
      "length": "0+",
      "element_types": ["string (dynlist_name)", "Tcl list of strings (dynlist_names)"],
      "constraints": "If provided, each argument or element in the Tcl list must be the name of an existing dynamic list."
    },
    "returns": {
      "type": "string (name of new DynList of type List)",
      "new_object": true,
      "element_type": "list (specifically, its elements are other dynamic lists)"
    },
    "errors": [
      "TCL_ERROR if any provided 'dynlist_name' is not found or is not a valid dynamic list.",
      "TCL_ERROR for memory allocation failures."
    ],
    "example": "set listA [dl_create 1 2]\nset listB [dl_slist hello world]\nset listC [dl_ilist 100]\n\nset lol1 [dl_llist]                 ;# Creates an empty list of lists\nset lol2 [dl_llist $listA $listB]   ;# Creates a list of lists containing listA and listB\n\nset names_tcl_list [list $listA $listC]\nset lol3 [dl_llist $names_tcl_list] ;# Creates list of lists from a Tcl list of dynlist names\n\n# dl_append $lol1 $listC ;# Now lol1 contains listC\n# dl_depth $lol2 ;# Should return 2",
    "see_also": ["dl_create", "dl_ilist", "dl_flist", "dl_slist", "dl_append", "dl_length", "dl_depth"]
  },
  {
    "command": "dl_local",
    "category": "Creation / Scoping",
    "synopsis": "dl_local new_dynlist_name [source_dynlist_to_copy | value1 value2 ... | {value_list}]",
    "brief": "Creates a new dynamic list, typically intended for local or temporary use. Can create an empty list, a copy of an existing list, or initialize with specified values. The 'local' nature might imply specific lifecycle management or naming conventions not inherent in 'dl_create'.",
    "inputs": {
      "type": "varied",
      "length": "1+",
      "element_types": ["string (new_dynlist_name)", "string (source_dynlist_to_copy, optional)", "any (value, optional)", "..."],
      "constraints": [
        "'new_dynlist_name' is the name for the list to be created.",
        "If 'source_dynlist_to_copy' is provided, it must be the name of an existing dynamic list; the new list will be a copy.",
        "Alternatively, literal values or a Tcl list of values can be provided to initialize the new list, similar to 'dl_create'.",
        "If no source/values are given after 'new_dynlist_name', an empty list is created whose type might be inferred or default."
      ]
    },
    "returns": {
      "type": "string (name of the new dynamic list)",
      "new_object": true,
      "element_type": "any (inferred from source/values, or default if empty)"
    },
    "errors": [
      "TCL_ERROR if 'new_dynlist_name' is an invalid name.",
      "TCL_ERROR if 'source_dynlist_to_copy' (if provided) is not found.",
      "TCL_ERROR if provided values are inconsistent for typing the new list.",
      "TCL_ERROR for memory allocation failures."
    ],
    "example": "set globalList [dl_create 10 20 30]\n\nproc my_operation {\n  # Create a local working copy of globalList\n  dl_local localCopy $globalList\n  dl_append $localCopy 40\n  puts \"Local copy inside proc: [dl_dump $localCopy]\"\n  # localCopy might be automatically cleaned up or just exist until explicitly deleted,\n  # depending on the exact semantics of 'dl_local'.\n\n  # Create another local list from values\n  dl_local tempList [dl_ilist 1 2 3]\n  puts \"Temp list inside proc: [dl_dump $tempList]\"\n  return [dl_sum $tempList]\n}\n\nmy_operation\nputs \"Global list after proc: [dl_dump $globalList]\" ;# Should be unchanged",
    "see_also": ["dl_create", "dl_copy", "dl_tempname", "dl_pushTemps", "dl_popTemps", "Tcl proc for variable scoping"]
  },
  {
    "command": "dl_log",
    "category": "Arithmetic / Transcendental",
    "synopsis": "dl_log dynlist_name | dl_log number",
    "brief": "Computes the element-wise natural logarithm (ln) of a dynamic list or a single number. Inputs must be positive. Returns a new list of floats.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"],
      "constraints": "Input elements must be positive numbers."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float"
    },
    "errors": [
      "TCL_ERROR if input list/number is not found or not numeric.",
      "TCL_ERROR if any input element is zero or negative (logarithm undefined).",
      "TCL_ERROR for general mathematical errors."
    ],
    "example": "set values [dl_create 1 2.71828 10 0.5] ;# e approx 2.71828\nset log_values [dl_log $values]\n# log_values will be approximately [0.0 1.0 2.30258 -0.69315]\n\ndl_log 100 ; # ln(100) approx 4.60517\n\n# dl_log 0 ; # Would cause an error\n# set neg_val [dl_create -2]\n# dl_log $neg_val ; # Would cause an error",
    "see_also": ["dl_exp", "dl_log10", "dl_lgamma", "dl_pow"]
  },
  {
    "command": "dl_log10",
    "category": "Arithmetic / Transcendental",
    "synopsis": "dl_log10 dynlist_name | dl_log10 number",
    "brief": "Computes the element-wise base-10 logarithm of a dynamic list or a single number. Inputs must be positive. Returns a new list of floats.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"],
      "constraints": "Input elements must be positive numbers."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float"
    },
    "errors": [
      "TCL_ERROR if input list/number is not found or not numeric.",
      "TCL_ERROR if any input element is zero or negative (logarithm undefined).",
      "TCL_ERROR for general mathematical errors."
    ],
    "example": "set values [dl_create 1 10 100 0.1 0.01]\nset log10_values [dl_log10 $values]\n# log10_values will be [0.0 1.0 2.0 -1.0 -2.0]\n\ndl_log10 1000 ; # Returns a list with [3.0]\n\n# dl_log10 0 ; # Would cause an error\n# set neg_val [dl_create -10]\n# dl_log10 $neg_val ; # Would cause an error",
    "see_also": ["dl_log", "dl_exp", "dl_pow"]
  },
  {
    "command": "dl_lt",
    "category": "Logical / Comparison",
    "synopsis": "dl_lt list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise less than (<) comparison. If more than two arguments, checks chained comparison (e.g., a<b AND b<c). Returns a new list of 0s and 1s.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "Result contains 0 (false) or 1 (true) for each element-wise comparison."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists/values are not compatible for comparison (cannot be broadcast or compared)."
    ],
    "example": "set l1 [dl_create 1 5 3 9 0]\nset l2 [dl_create 2 5 1 8 2]\nset res1 [dl_lt $l1 $l2]   ;# res1 is [1 0 0 0 1]\nset res2 [dl_lt $l1 3]     ;# res2 is [1 0 0 0 1] (l1 compared to scalar 3)\n\nset l3 [dl_create 7 7 7]\n# For chained: (l1 < l3) AND (l3 < 8)\nset res3 [dl_lt $l1 $l3 8] ;# Example: l1[0]=1, l3[0]=7 -> (1<7 AND 7<8) -> 1. l1[3]=9, l3[any]=7 -> (9<7 is false) -> 0",
    "see_also": ["dl_gt", "dl_lte", "dl_gte", "dl_eq", "dl_noteq", "dl_ltIndex"]
  },
  {
    "command": "dl_ltIndex",
    "category": "Logical / Comparison / Indexing",
    "synopsis": "dl_ltIndex list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise less than (<) comparison and returns a new list of 0-based indices where true. For chained comparisons (e.g. a<b AND b<c), indices are where the entire chain is true.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 0-based indices where the comparison is true."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists/values are not compatible for comparison (cannot be broadcast or compared)."
    ],
    "example": "set l1 [dl_create 1 5 3 9 0]\nset l2 [dl_create 2 5 1 8 2]\nset idx1 [dl_ltIndex $l1 $l2] ;# idx1 is [0 4]\nset idx2 [dl_ltIndex $l1 3]   ;# idx2 is [0 4]\n\nset l3 [dl_create 7 7 7]\n# For chained: (l1 < l3) AND (l3 < 8)\nset idx3 [dl_ltIndex $l1 $l3 8] ;# Example: l1[0]=1,l3[0]=7 -> (1<7 AND 7<8) -> true, index 0.",
    "see_also": ["dl_lt", "dl_gtIndex", "dl_lteIndex", "dl_gteIndex", "dl_eqIndex", "dl_noteqIndex"]
  },
  {
    "command": "dl_lte",
    "category": "Logical / Comparison",
    "synopsis": "dl_lte list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise less than or equal to (<=) comparison. If more than two arguments, checks chained comparison (e.g., a<=b AND b<=c). Returns a new list of 0s and 1s.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "Result contains 0 (false) or 1 (true) for each element-wise comparison."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists/values are not compatible for comparison (cannot be broadcast or compared)."
    ],
    "example": "set l1 [dl_create 1 5 3 8 0]\nset l2 [dl_create 2 5 1 8 2]\nset res1 [dl_lte $l1 $l2]  ;# res1 is [1 1 0 1 1]\nset res2 [dl_lte $l1 3]    ;# res2 is [1 0 1 0 1] (l1 compared to scalar 3)\n\nset l3 [dl_create 7 7 7]\n# For chained: (l1 <= l3) AND (l3 <= 7)\nset res3 [dl_lte $l1 $l3 7] ;# Example: l1[0]=1,l3[0]=7 -> (1<=7 AND 7<=7) -> 1. l1[3]=8 -> (8<=7 is false) -> 0",
    "see_also": ["dl_lt", "dl_gt", "dl_gte", "dl_eq", "dl_noteq", "dl_lteIndex"]
  },
  {
    "command": "dl_lteIndex",
    "category": "Logical / Comparison / Indexing",
    "synopsis": "dl_lteIndex list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise less than or equal to (<=) comparison and returns a new list of 0-based indices where true. For chained comparisons (e.g. a<=b AND b<=c), indices are where the entire chain is true.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 0-based indices where the comparison is true."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists/values are not compatible for comparison (cannot be broadcast or compared)."
    ],
    "example": "set l1 [dl_create 1 5 3 8 0]\nset l2 [dl_create 2 5 1 8 2]\nset idx1 [dl_lteIndex $l1 $l2] ;# idx1 is [0 1 3 4]\nset idx2 [dl_lteIndex $l1 3]   ;# idx2 is [0 2 4]\n\nset l3 [dl_create 7 7 7]\n# For chained: (l1 <= l3) AND (l3 <= 7)\nset idx3 [dl_lteIndex $l1 $l3 7] ;# Example: l1[0]=1,l3[0]=7 -> (1<=7 AND 7<=7) -> true, index 0.",
    "see_also": ["dl_lte", "dl_ltIndex", "dl_gtIndex", "dl_gteIndex", "dl_eqIndex", "dl_noteqIndex"]
  },
  {
    "command": "dl_lt",
    "category": "Logical / Comparison",
    "synopsis": "dl_lt list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise less than (<) comparison. If more than two arguments, checks chained comparison (e.g., a<b AND b<c). Returns a new list of 0s and 1s.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "Result contains 0 (false) or 1 (true) for each element-wise comparison."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists/values are not compatible for comparison (cannot be broadcast or compared)."
    ],
    "example": "set l1 [dl_create 1 5 3 9 0]\nset l2 [dl_create 2 5 1 8 2]\nset res1 [dl_lt $l1 $l2]   ;# res1 is [1 0 0 0 1]\nset res2 [dl_lt $l1 3]     ;# res2 is [1 0 0 0 1] (l1 compared to scalar 3)\n\nset l3 [dl_create 7 7 7]\n# For chained: (l1 < l3) AND (l3 < 8)\nset res3 [dl_lt $l1 $l3 8] ;# Example: l1[0]=1, l3[0]=7 -> (1<7 AND 7<8) -> 1. l1[3]=9, l3[any]=7 -> (9<7 is false) -> 0",
    "see_also": ["dl_gt", "dl_lte", "dl_gte", "dl_eq", "dl_noteq", "dl_ltIndex"]
  },
  {
    "command": "dl_ltIndex",
    "category": "Logical / Comparison / Indexing",
    "synopsis": "dl_ltIndex list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise less than (<) comparison and returns a new list of 0-based indices where true. For chained comparisons (e.g. a<b AND b<c), indices are where the entire chain is true.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 0-based indices where the comparison is true."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists/values are not compatible for comparison (cannot be broadcast or compared)."
    ],
    "example": "set l1 [dl_create 1 5 3 9 0]\nset l2 [dl_create 2 5 1 8 2]\nset idx1 [dl_ltIndex $l1 $l2] ;# idx1 is [0 4]\nset idx2 [dl_ltIndex $l1 3]   ;# idx2 is [0 4]\n\nset l3 [dl_create 7 7 7]\n# For chained: (l1 < l3) AND (l3 < 8)\nset idx3 [dl_ltIndex $l1 $l3 8] ;# Example: l1[0]=1,l3[0]=7 -> (1<7 AND 7<8) -> true, index 0.",
    "see_also": ["dl_lt", "dl_gtIndex", "dl_lteIndex", "dl_gteIndex", "dl_eqIndex", "dl_noteqIndex"]
  },
  {
    "command": "dl_max",
    "category": "Reduction / Statistics",
    "synopsis": "dl_max dynlist_name",
    "brief": "Returns the maximum value from a 1D numeric dynamic list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["string (name of a 1D numeric dynamic list)"],
      "constraints": "The dynamic list must be 1D and contain numeric elements. List must not be empty."
    },
    "returns": {
      "type": "numeric",
      "new_object": false,
      "brief": "A single value representing the maximum element in the list. Type matches list\\'s element type (or float if mixed)."
    },
    "errors": [
      "TCL_ERROR if \\'dynlist_name\\' is not found.",
      "TCL_ERROR if the list is not 1D or is not numeric.",
      "TCL_ERROR if the list is empty."
    ],
    "example": "set myInts [dl_ilist 10 50 20 5]\nset max_val1 [dl_max $myInts]  ;# max_val1 is 50\n\nset myFloats [dl_flist -1.0 2.5 -5.0 0.0]\nset max_val2 [dl_max $myFloats] ;# max_val2 is 2.5\n\n# set emptyList [dl_create]\n# dl_max $emptyList ;# Would likely error",
    "see_also": ["dl_min", "dl_max_positions", "dl_bmax", "dl_sum", "dl_mean", "dl_sort"]
  },
  {
    "command": "dl_max_positions",
    "category": "Reduction / Statistics / Indexing",
    "synopsis": "dl_max_positions dynlist_name",
    "brief": "Returns a new list containing the 0-based indices of all occurrences of the maximum value in a 1D numeric dynamic list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["string (name of a 1D numeric dynamic list)"],
      "constraints": "The dynamic list must be 1D and contain numeric elements. List must not be empty."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 0-based indices where the maximum value is found. Empty list if input is empty (though an error is more likely for empty input based on dl_max)."
    },
    "errors": [
      "TCL_ERROR if \\'dynlist_name\\' is not found.",
      "TCL_ERROR if the list is not 1D or is not numeric.",
      "TCL_ERROR if the list is empty."
    ],
    "example": "set myInts [dl_ilist 10 50 20 50 5 50]\nset max_pos1 [dl_max_positions $myInts]  ;# max_pos1 is [1 3 5]\n\nset myFloats [dl_flist -1.0 2.5 -5.0 2.5 0.0]\nset max_pos2 [dl_max_positions $myFloats] ;# max_pos2 is [1 3]\n\nset singleMax [dl_ilist 1 2 5 3 4]\nset max_pos3 [dl_max_positions $singleMax] ;# max_pos3 is [2]",
    "see_also": ["dl_max", "dl_min_positions", "dl_min", "dl_find", "dl_eqIndex"]
  },
  {
    "command": "dl_mean",
    "category": "Reduction / Statistics",
    "synopsis": "dl_mean dynlist_name",
    "brief": "Calculates the arithmetic mean (average) of the elements in a 1D numeric dynamic list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["string (name of a 1D numeric dynamic list)"],
      "constraints": "The dynamic list must be 1D and contain numeric elements (integers or floats). List must not be empty."
    },
    "returns": {
      "type": "float",
      "new_object": false,
      "brief": "A single float value representing the arithmetic mean of the list elements."
    },
    "errors": [
      "TCL_ERROR if \\'dynlist_name\\' is not found.",
      "TCL_ERROR if the list is not 1D or is not numeric.",
      "TCL_ERROR if the list is empty (division by zero)."
    ],
    "example": "set myInts [dl_ilist 10 20 30 40 50]\nset mean_val1 [dl_mean $myInts]  ;# mean_val1 is 30.0\n\nset myFloats [dl_flist 1.0 1.5 2.0 2.5 3.0]\nset mean_val2 [dl_mean $myFloats] ;# mean_val2 is 2.0\n\nset mixed_content [dl_create 1 2.0 3 4.0] ;# Likely treated as floats\nset mean_val3 [dl_mean $mixed_content] ;# mean_val3 is 2.5",
    "see_also": ["dl_sum", "dl_std", "dl_var", "dl_median (if exists)", "dl_hmean", "dl_bmean"]
  },
  {
    "command": "dl_mean_list",
    "category": "Reduction / Statistics",
    "synopsis": "dl_mean_list dynlist_name",
    "brief": "Calculates the arithmetic mean of elements in a 1D numeric list. Returns the mean as a single-element float list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["string (name of a 1D numeric dynamic list)"],
      "constraints": "The dynamic list must be 1D and contain numeric elements. List must not be empty."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "float",
      "brief": "A new single-element dynamic list containing the float mean value."
    },
    "errors": [
      "TCL_ERROR if \'dynlist_name\' is not found.",
      "TCL_ERROR if the list is not 1D or is not numeric.",
      "TCL_ERROR if the list is empty."
    ],
    "example": "set myInts [dl_ilist 10 20 30 40 50]\nset mean_list1 [dl_mean_list $myInts]  ;# mean_list1 is a dynlist: [30.0]\n# set mean_val [dl_first $mean_list1] ;# mean_val is 30.0\n\nset myFloats [dl_flist 1.0 1.5 2.0]\nset mean_list2 [dl_mean_list $myFloats] ;# mean_list2 is a dynlist: [1.5]",
    "see_also": ["dl_mean", "dl_bmean", "dl_sum", "dl_std"]
  },
  {
    "command": "dl_min",
    "category": "Reduction / Statistics",
    "synopsis": "dl_min dynlist_name",
    "brief": "Returns the minimum value from a 1D numeric dynamic list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["string (name of a 1D numeric dynamic list)"],
      "constraints": "The dynamic list must be 1D and contain numeric elements. List must not be empty."
    },
    "returns": {
      "type": "numeric",
      "new_object": false,
      "brief": "A single value representing the minimum element in the list. Type matches list\'s element type (or float if mixed)."
    },
    "errors": [
      "TCL_ERROR if \'dynlist_name\' is not found.",
      "TCL_ERROR if the list is not 1D or is not numeric.",
      "TCL_ERROR if the list is empty."
    ],
    "example": "set myInts [dl_ilist 10 50 20 5 30]\nset min_val1 [dl_min $myInts]  ;# min_val1 is 5\n\nset myFloats [dl_flist -1.0 2.5 -5.0 0.0]\nset min_val2 [dl_min $myFloats] ;# min_val2 is -5.0",
    "see_also": ["dl_max", "dl_min_positions", "dl_bmin", "dl_sum", "dl_mean", "dl_sort"]
  },
  {
    "command": "dl_min_positions",
    "category": "Reduction / Statistics / Indexing",
    "synopsis": "dl_min_positions dynlist_name",
    "brief": "Returns a new list containing the 0-based indices of all occurrences of the minimum value in a 1D numeric dynamic list.",
    "inputs": {
      "type": "string (dynlist_name)",
      "length": 1,
      "element_types": ["string (name of a 1D numeric dynamic list)"],
      "constraints": "The dynamic list must be 1D and contain numeric elements. List must not be empty."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 0-based indices where the minimum value is found."
    },
    "errors": [
      "TCL_ERROR if \'dynlist_name\' is not found.",
      "TCL_ERROR if the list is not 1D or is not numeric.",
      "TCL_ERROR if the list is empty."
    ],
    "example": "set myInts [dl_ilist 10 5 20 5 30 5]\nset min_pos1 [dl_min_positions $myInts]  ;# min_pos1 is [1 3 5]\n\nset myFloats [dl_flist -1.0 2.5 -5.0 0.0 -5.0]\nset min_pos2 [dl_min_positions $myFloats] ;# min_pos2 is [2 4]\n\nset singleMin [dl_ilist 5 2 3 4]\nset min_pos3 [dl_min_positions $singleMin] ;# min_pos3 is [1]",
    "see_also": ["dl_min", "dl_max_positions", "dl_max", "dl_find", "dl_eqIndex"]
  },
  {
    "command": "dl_mod",
    "category": "Arithmetic",
    "synopsis": "dl_mod dividend_list_or_val divisor_list_or_val",
    "brief": "Computes the element-wise integer modulo (remainder) of dividend / divisor. The result typically has the same sign as the divisor. Returns a new list.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 2,
      "element_types": ["numeric", "numeric"],
      "constraints": "Inputs must be numeric and broadcastable. Divisor elements must be non-zero. If inputs are floats, they may be truncated to integers before the operation, or it may behave like fmod."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer (typically, or float if inputs were float and fmod-like behavior occurs)"
    },
    "errors": [
      "TCL_ERROR if any input list is not found or not numeric.",
      "TCL_ERROR if lists are not compatible for the operation (cannot be broadcast).",
      "TCL_ERROR if division by zero is attempted for any element."
    ],
    "example": "set l1 [dl_ilist 5 -5 5 -5 7]\nset l2 [dl_ilist 3 3 -3 -3 3]\n# Assuming result takes sign of divisor for Tcl-like %:\n# 5 % 3 = 2\n# -5 % 3 = 1 (since -5 = -2*3 + 1)\n# 5 % -3 = -1 (since 5 = -1*-3 + 2, or 5 = -2*-3 -1 -> -1)\n# -5 % -3 = -2 (since -5 = 1*-3 - 2, or -5 = 2*-3 +1 -> -2)\n# 7 % 3 = 1\nset res [dl_mod $l1 $l2]  ;# Expected: res could be [2 1 -1 -2 1]\n\nset res2 [dl_mod $l1 2] ;# Example: [1 -1 1 -1 1]",
    "see_also": ["dl_fmod", "dl_div"]
  },
  {
    "command": "dl_mult",
    "category": "Arithmetic",
    "synopsis": "dl_mult list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise multiplication of two or more dynamic lists or numbers. Returns a new list.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": "2+",
      "element_types": ["numeric"],
      "constraints": "Inputs must be numeric and broadcastable (e.g., same length or one is a scalar/1-element list)."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Numeric (promoted to float if mixed types or to avoid overflow)"
    },
    "errors": [
      "TCL_ERROR if any input list is not found or not numeric.",
      "TCL_ERROR if lists are not compatible for multiplication (cannot be broadcast)."
    ],
    "example": "set l1 [dl_create 1 2 3.0]\nset l2 [dl_create 10 5 2.0]\nset l3 [dl_mult $l1 $l2]      ;# l3 is [10.0 10.0 6.0]\nset l4 [dl_mult $l1 2]        ;# l4 is [2.0 4.0 6.0]\nset l5 [dl_create 0.5]\nset l6 [dl_mult $l1 $l2 $l5] ;# l6 is [5.0 5.0 3.0] ( (1*10)*0.5, (2*5)*0.5, (3*2)*0.5 )",
    "see_also": ["dl_add", "dl_sub", "dl_div", "dl_prod"]
  },
  {
    "command": "dl_negate",
    "category": "Arithmetic",
    "synopsis": "dl_negate dynlist_name | dl_negate number",
    "brief": "Computes the element-wise negation (changes sign) of a dynamic list or a single number. Returns a new list.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "Same as input (or float if input is mixed or float)"
    },
    "errors": [
      "TCL_ERROR if input list is not found or is not numeric (e.g., a string list).",
      "TCL_ERROR for general math errors."
    ],
    "example": "set myList [dl_create -2 0 3.5 -1.2]\nset negList [dl_negate $myList] ;# negList will be [2 0 -3.5 1.2]\ndl_negate 5 ;# returns a new list containing [-5]\ndl_negate -7.7 ;# returns a new list containing [7.7]",
    "see_also": ["dl_abs", "dl_sub"]
  },
  {
    "command": "dl_not",
    "category": "Logical",
    "synopsis": "dl_not dynlist_name | dl_not number",
    "brief": "Performs element-wise logical NOT on a numeric dynamic list or number. Returns a new list of 0s and 1s.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": 1,
      "element_types": ["numeric"],
      "constraints": "Input list must be numeric (not string). Elements are treated as boolean (0 is false, non-zero is true)."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "Result contains 0 (false) or 1 (true). `not 0` is 1; `not non-zero` is 0."
    },
    "errors": [
      "TCL_ERROR if input list is not found or is a string list."
    ],
    "example": "set l1 [dl_create 1 0 -2.5 0.0 7]\nset l2 [dl_not $l1]   ;# l2 is [0 1 0 1 0]\ndl_not 0            ;# returns a list containing [1]\ndl_not 100          ;# returns a list containing [0]",
    "see_also": ["dl_and", "dl_or", "dl_eq", "dl_noteq"]
  },
  {
    "command": "dl_noteq",
    "category": "Logical / Comparison",
    "synopsis": "dl_noteq list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise inequality (!=) comparison. If more than two arguments, checks chained inequality (e.g., a!=b AND b!=c). Returns a new list of 0s and 1s.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "Result contains 0 (false) or 1 (true) for each element-wise comparison."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists are not compatible for comparison (cannot be broadcast)."
    ],
    "example": "set l1 [dl_create 1 2 3 2 5]\nset l2 [dl_create 1 2 4 3 5]\nset res1 [dl_noteq $l1 $l2] ;# res1 is [0 0 1 1 0]\nset res2 [dl_noteq $l1 2]   ;# res2 is [1 0 1 0 1]\n\nset s1 [dl_slist a b c]\nset s2 [dl_slist a d c]\nset res3 [dl_noteq $s1 $s2] ;# res3 is [0 1 0]\n\nset l3 [dl_create 2 2 2]\nset res4 [dl_noteq $l1 $l3 7] ;# (l1!=l3 AND l3!=7). l1!=l3 -> [1 0 1 0 1]. l3!=7 -> [1 1 1]. Result: [1 0 1 0 1]",
    "see_also": ["dl_eq", "dl_gt", "dl_lt", "dl_and", "dl_or", "dl_noteqIndex"]
  },
  {
    "command": "dl_noteqIndex",
    "category": "Logical / Comparison / Indexing",
    "synopsis": "dl_noteqIndex list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise inequality (!=) comparison and returns a new list of 0-based indices where true. For chained comparisons, indices are where the entire chain is true.",
    "inputs": {
      "type": "DynList_or_Any",
      "length": "2+",
      "element_types": ["any"],
      "constraints": "Inputs must be broadcastable. Elements should be comparable using Tcl's rules."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 0-based indices where the comparison is true."
    },
    "errors": [
      "TCL_ERROR if any input list (if name provided) is not found.",
      "TCL_ERROR if lists are not compatible for comparison (cannot be broadcast)."
    ],
    "example": "set l1 [dl_create 1 2 3 2 5]\nset l2 [dl_create 1 2 4 3 5]\nset idx1 [dl_noteqIndex $l1 $l2] ;# idx1 is [2 3]\nset idx2 [dl_noteqIndex $l1 2]   ;# idx2 is [0 2 4]\n\nset s1 [dl_slist a b c]\nset s2 [dl_slist a d c]\nset idx3 [dl_noteqIndex $s1 $s2] ;# idx3 is [1]\n\nset l3 [dl_create 2 2 2]\nset idx4 [dl_noteqIndex $l1 $l3 7] ;# (l1!=l3 AND l3!=7). Indices from [1 0 1 0 1] AND [1 1 1] -> [0 2 4]",
    "see_also": ["dl_noteq", "dl_eqIndex", "dl_gtIndex", "dl_ltIndex", "dl_andIndex", "dl_orIndex"]
  },
  {
    "command": "dl_oneof",
    "category": "Logical / Membership",
    "synopsis": "dl_oneof source_dynlist_name allowed_values_dynlist_name",
    "brief": "Checks for each element in 'source_dynlist' if it is present in 'allowed_values_dynlist'. Returns a new list of 0s (not found) and 1s (found).",
    "inputs": {
      "type": "varied",
      "length": 2,
      "element_types": ["string (source_dynlist_name)", "string (allowed_values_dynlist_name)"],
      "constraints": [
        "Both inputs must be valid dynlist names.",
        "Elements in 'source_dynlist' must be comparable to elements in 'allowed_values_dynlist'."
      ]
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A new list of the same length as 'source_dynlist', containing 1 if the corresponding element is in 'allowed_values_dynlist', 0 otherwise."
    },
    "errors": [
      "TCL_ERROR if 'source_dynlist_name' or 'allowed_values_dynlist_name' are not found.",
      "TCL_ERROR if elements are not comparable between the lists."
    ],
    "example": "set src [dl_slist a b c d a e f b]\nset allowed [dl_slist a d g]\nset result [dl_oneof $src $allowed] ;# result is [1 0 0 1 1 0 0 0]\n\nset nums_src [dl_ilist 10 20 30 40 10 50]\nset nums_allowed [dl_ilist 10 30 60]\nset num_result [dl_oneof $nums_src $nums_allowed] ;# num_result is [1 0 1 0 1 0]",
    "see_also": ["dl_find", "dl_findAll", "dl_first_index_list", "dl_last_index_list", "dl_eqIndex"]
  },
  {
    "command": "dl_ones",
    "category": "Creation",
    "synopsis": "dl_ones count [-type type_string]",
    "brief": "Creates a new dynamic list of 'count' elements, all initialized to 1. Default type is integer, can be float with -type float.",
    "inputs": {
      "type": "varied",
      "length": "1-3",
      "element_types": ["integer (count)", "string (-type, optional literal)", "string (type_string, e.g. int, float, optional)"],
      "constraints": "'count' must be a non-negative integer. If '-type' is used, 'type_string' specifies the list type (typically 'int' or 'float'). Defaults to integer ones."
    },
    "returns": {
      "type": "string (name of new DynList)",
      "new_object": true,
      "element_type": "integer or float"
    },
    "errors": [
      "TCL_ERROR if 'count' is not a non-negative integer.",
      "TCL_ERROR if 'value' is not 1 or if an invalid 'type_string' is provided."
    ],
    "example": "set list1 [dl_ones 5]              ;# list1 is an integer list: [1 1 1 1 1]\nset list2 [dl_ones 3 -type float]  ;# list2 is a float list: [1.0 1.0 1.0]\n# dl_ones 0 ;# creates an empty list of default type (likely integer)",
    "see_also": ["dl_zeros", "dl_fill", "dl_create", "dl_repeat"]
  },
  {
    "command": "dl_or",
    "category": "Logical",
    "synopsis": "dl_or list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise logical OR operation on two or more numeric dynamic lists or numbers. Returns a new list of 0s and 1s.",
    "inputs": {
      "type": "DynList_or_Number",
      "length": "2+",
      "element_types": ["numeric"],
      "constraints": "Inputs must be numeric (not string) and broadcastable. Elements are treated as boolean (0 is false, non-zero is true)."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "Result contains 0 (false) or 1 (true). `A or B` is 1 if A is true or B is true (or both)."
    },
    "errors": [
      "TCL_ERROR if any input list is not found or is a string list.",
      "TCL_ERROR if lists/values are not compatible for the OR operation (cannot be broadcast)."
    ],
    "example": "set l1 [dl_create 1 0 1 0]\nset l2 [dl_create 1 1 0 0]\nset l3 [dl_or $l1 $l2]    ;# l3 is [1 1 1 0]\nset l4 [dl_or $l1 0]      ;# l4 is [1 0 1 0] (0 is broadcast, treated as false)\nset l5 [dl_create 0 0 0 0]\nset l6 [dl_or $l1 $l2 $l5] ;# l6 is [1 1 1 0]",
    "see_also": ["dl_and", "dl_not", "dl_eq", "dl_orIndex"]
  },
  {
    "command": "dl_orIndex",
    "category": "Logical / Indexing",
    "synopsis": "dl_orIndex list1_or_val list2_or_val [list3_or_val ...]",
    "brief": "Performs element-wise logical OR on numeric lists/values and returns a new list containing the 0-based indices where the result is true (1).",
    "inputs": {
      "type": "DynList_or_Number",
      "length": "2+",
      "element_types": ["numeric"],
      "constraints": "Inputs must be numeric (not string) and broadcastable. Elements are treated as boolean (0 is false, non-zero is true)."
    },
    "returns": {
      "type": "DynList",
      "new_object": true,
      "element_type": "integer",
      "brief": "A list of 0-based indices where the logical OR is true."
    },
    "errors": [
      "TCL_ERROR if any input list is not found or is a string list.",
      "TCL_ERROR if lists/values are not compatible for the OR operation (cannot be broadcast)."
    ],
    "example": "set l1 [dl_create 1 0 1 0 0]\nset l2 [dl_create 1 1 0 0 0]\nset idx [dl_orIndex $l1 $l2]    ;# idx is [0 1 2] (l1[0] OR l2[0] is true, l1[1] OR l2[1] is true, l1[2] OR l2[2] is true)\nset l3 [dl_create 0 0 0 1 0]\nset idx2 [dl_orIndex $l1 $l2 $l3] ;# (l1 OR l2 OR l3). idx2 is [0 1 2 3]",
    "see_also": ["dl_or", "dl_andIndex", "dl_eqIndex", "dl_select", "dl_noteqIndex"]
  }
]
